// ************************************************************************ //
// WARNING
// -------
// This file is generated by the Type Library importer or Type Libary Editor.
// Barring syntax errors, the Editor will parse modifications made to the file.
// However, when applying changes via the Editor this file will be regenerated
// and comments or formatting changes will be lost.
// ************************************************************************ //
// File generated on 9/27/2011 2:31:14 PM (- $Rev: 12980 $, 107564031).

[
  uuid(8BFDE413-245A-4514-B151-B16DCC243796),
  version(1.0),
  helpstring("OpenDSS Engine")

]
library OpenDSSengine
{

  importlib("stdole2.tlb");
  importlib("stdole32.tlb");

  interface IText;
  coclass Text;
  interface IDSSProperty;
  coclass DSSProperty;
  interface ICktElement;
  coclass CktElement;
  interface IError;
  coclass Error;
  interface ICircuit;
  coclass Circuit;
  interface IBus;
  coclass Bus;
  interface IDSS;
  coclass DSS;
  interface ISolution;
  coclass Solution;
  interface IMonitors;
  coclass Monitors;
  interface IMeters;
  coclass Meters;
  interface IGenerators;
  coclass Generators;
  interface IDSSProgress;
  coclass DSSProgress;
  interface ISettings;
  coclass Settings;
  interface ILines;
  coclass Lines;
  interface ICtrlQueue;
  coclass CtrlQueue;
  interface ILoads;
  coclass Loads;
  interface IDSSElement;
  coclass DSSElement;
  interface IActiveClass;
  coclass ActiveClass;
  interface ICapacitors;
  coclass Capacitors;
  interface ITransformers;
  interface ISwtControls;
  interface ICapControls;
  interface IRegControls;
  coclass Transformers;
  coclass SwtControls;
  coclass CapControls;
  coclass RegControls;
  interface IPlot;
  coclass Plot;
  interface ITopology;
  coclass Topology;
  interface IDSS_Executive;
  coclass DSS_Executive;
  interface IDSSEvents;
  dispinterface IDSSEventsEvents;
  coclass DSSEvents;
  interface ISensors;
  coclass Sensors;


  [
    uuid(F694AF7D-DE1E-4CC2-8944-7D574FA06E3B),
    version(1.0),
    helpstring("Modes for Monitors\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum MonitorModes
  {
    [helpstring("Monitor records Voltage and Current (Default)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssVI = 0,
    [helpstring("Powers\0 records Voltage and Current (Default)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPower = 1,
    [helpstring("Reports sequence quantities\0Current (Default)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssSequence = 16,
    [helpstring("Matnitude Only\0e quantities\0Current (Default)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMagnitude = 32,
    [helpstring("Positive Seq only or avg of all phases\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPosOnly = 64,
    [helpstring("Regulator and Transformer taps\0 phases\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssTaps = 2,
    [helpstring("State Variables (PC Elements only)\0ses\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssStates = 3
  };

  [
    uuid(421FFC54-1D6B-4900-B598-9E3E7E10FDD1),
    version(1.0),
    helpstring("\0\0des for Monitors\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum SolveModes
  {
    [helpstring("Solve a single snapshot power flow\0ses\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssSnapShot = 0,
    [helpstring("Solve following Duty Cycle load shapes\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssDutyCycle = 6,
    [helpstring("Solve direct (forced admittance model)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssDirect = 7,
    [helpstring("Solve following Daily load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssDaily = 1,
    [helpstring("Monte Carlo Mode 1\0ly load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonte1 = 3,
    [helpstring("Monte Carlo Mode 2\0ly load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonte2 = 10,
    [helpstring("Monte Carlo Mode 3\0ly load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonte3 = 11,
    [helpstring("Fault study at all buses\0d shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssFaultStudy = 9,
    [helpstring("Solve following Yearly load shapes\0el)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssYearly = 2,
    [helpstring("Monte carlo Fault Study\0oad shapes\0el)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonteFault = 8,
    [helpstring("Solves for Peak Day using Daily load curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPeakDay = 5,
    [helpstring("Load-duration Mode 1\0sing Daily load curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssLD1 = 4,
    [helpstring("Load-Duration Mode 2\0sing Daily load curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssLD2 = 12,
    [helpstring("Auto add generators or capacitors\0ad curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAutoAdd = 13,
    dssHarmonic = 15,
    dssDynamic = 14
  };

  [
    uuid(21B577B3-3F77-49B2-8F4D-A21BACDF6964),
    version(1.0),
    helpstring("\0\0des for Monitors\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum Options
  {
    [helpstring("Power Flow load model option\0tors\0ad curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPowerFlow = 1,
    [helpstring("Admittance load model option\0tors\0ad curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAdmittance = 2,
    [helpstring("Solution algorithm option - Normal solution mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssNormalSolve = 0,
    [helpstring("Solution algorithm option - Newton solution\0mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssNewtonSolve = 1,
    [helpstring("Control Mode option - Static\0ewton solution\0mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssStatic = 0,
    [helpstring("Control Mode Option - Event driven solution mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssEvent = 1,
    [helpstring("Control mode option - Time driven mode\0tion mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssTime = 2,
    [helpstring("Circuit model is multiphase (default)\0\0tion mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMultiphase = 0,
    [helpstring("Circuit model is positive sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPositiveSeq = 1,
    [helpstring("Random mode = Gaussian\0ve sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssGaussian = 1,
    [helpstring("Random mode = Uniform\0\0ve sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssUniform = 2,
    [helpstring("Random Mode = Log normal\0 sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssLogNormal = 3,
    [helpstring("Add generators in AutoAdd mode (AddType)\0only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAddGen = 1,
    [helpstring("Add capacitors in AutoAdd mode (Addtype)\0only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAddCap = 2
  };

  [
    uuid(6DB3AE70-08E2-45D4-8E83-412C246F4C17),
    version(1.0),
    helpstring("\0\x01o\0d\0e\0C\0e\0n\0t\0r\0a\0l\0 \0E\0x\0a\0m\0p\0l\0e\0s\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum CapControlModes
  {
    [helpstring("voltage control, ON and OFF settings on the PT secondary base\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlVoltage = 1,
    [helpstring("kVAR control, ON and OFF settings on PT / CT base\0ondary base\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlKVAR = 2,
    [helpstring("Current control, ON and OFF settings on CT secondary\0ary base\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlCurrent = 0,
    [helpstring("ON and OFF settings are power factor, negative for leading\0se\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlPF = 4,
    [helpstring("Time control, ON and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlTime = 3
  };

  [
    uuid(CF246BDE-E2C7-4F1E-9227-A95F8F65F39F),
    version(1.0),
    helpstring("\0\x01o\0d\0e\0C\0e\0n\0t\0r\0a\0l\0 \0E\0x\0a\0m\0p\0l\0e\0s\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum ActionCodes
  {
    [helpstring("No action\0ol, ON and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionNone = 0,
    [helpstring("Open a switch\0ON and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionOpen = 1,
    [helpstring("Close a switch\0N and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionClose = 2,
    [helpstring("Reset to the shelf state (unlocked, closed for a switch)\0ht\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionReset = 3,
    [helpstring("Lock a switch, prventing both manual and automatic operation\0\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionLock = 4,
    [helpstring("Unlock a switch, permitting both manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionUnlock = 5,
    [helpstring("Move a regulator tap up\0ing both manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionTapUp = 6,
    [helpstring("Move a regulator tap down\0g both manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionTapDown = 7
  };

  [
    uuid(A6526195-0103-45C1-B338-B9875F0B0A96)
  ]
  enum LoadStatus
  {
    dssLoadVariable = 0,
    dssLoadFixed = 1,
    dssLoadExempt = 2
  };

  [
    uuid(83BCFDCC-1FAF-4343-9930-2B6D02F6417D)
  ]
  enum LoadModels
  {
    dssLoadConstPQ = 1,
    dssLoadConstZ = 2,
    dssLoadMotor = 3,
    dssLoadCVR = 4,
    dssLoadConstI = 5,
    dssLoadConstPFixedQ = 6,
    dssLoadConstPFixedX = 7
  };

  [
    uuid(0513A8DC-2C0D-4648-8BD7-2130B82C05FA),
    version(1.0),
    helpstring("Dispatch interface for Text Object\0\0e\0;\0p\x12\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IText: IDispatch
  {
    [propget, id(0x00000001), helpstring("Input command string for the DSS.\0ve Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Command([out, retval] BSTR* Command);
    [propput, id(0x00000001), helpstring("Input command string for the DSS.\0ve Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Command([in] BSTR Command);
    [propget, id(0x00000002), helpstring("Result string for the last command.\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Result([out, retval] BSTR* Result);
  };

  [
    uuid(1298D126-0750-4B2A-8462-62EFE7310DF2),
    version(1.0),
    helpstring("Dispatch interface for DSSProperty Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IDSSProperty: IDispatch
  {
    [propget, id(0x00000001), helpstring("Name of Property\0 the last command.\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Name);
    [propget, id(0x00000003), helpstring("Description of the property.\0mmand.\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Description([out, retval] BSTR* Description);
    [propget, id(0x00000002)]
    HRESULT _stdcall Val([out, retval] BSTR* Value);
    [propput, id(0x00000002)]
    HRESULT _stdcall Val([in] BSTR Value);
  };

  [
    uuid(F20E8327-5B60-478E-8DBD-5EFC75EB929B),
    version(1.0),
    helpstring("Dispatch interface for CktElement Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface ICktElement: IDispatch
  {
    [propget, id(0x00000001), helpstring("Full Name of Active Circuit Element\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propget, id(0x00000002), helpstring("Number of Terminals this Circuit Element\0ct\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumTerminals([out, retval] long* Value);
    [propget, id(0x00000003), helpstring("Number of Conductors per Terminal\0lement\0ct\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumConductors([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Number of Phases\0ors per Terminal\0lement\0ct\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumPhases([out, retval] long* Value);
    [propget, id(0x00000005), helpstring("Variant array of strings. Set Bus definitions for each terminal is connected.\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall BusNames([out, retval] VARIANT* Value);
    [propput, id(0x00000005), helpstring("Variant array of strings. Set Bus definitions for each terminal is connected.\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall BusNames([in] VARIANT Value);
    [propget, id(0x00000006), helpstring("Collection of Properties for this Circuit Element (0 based index, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Properties([in] VARIANT Indx, [out, retval] IDSSProperty** Value);
    [propget, id(0x00000007), helpstring("Complex array of voltages at terminals\0it Element (0 based index, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Voltages([out, retval] VARIANT* Value);
    [propget, id(0x00000008), helpstring("Complex array of currents into each conductor of each terminal\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Currents([out, retval] VARIANT* Value);
    [propget, id(0x00000009), helpstring("Complex array of powers into each conductor of each terminal\0l\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Powers([out, retval] VARIANT* Value);
    [propget, id(0x0000000A), helpstring("Total losses in the element: two-element complex array\0minal\0l\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Losses([out, retval] VARIANT* Value);
    [propget, id(0x0000000B), helpstring("Complex array of losses by phase\0element complex array\0minal\0l\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PhaseLosses([out, retval] VARIANT* Value);
    [propget, id(0x0000000C), helpstring("Double array of symmetrical component voltages at each 3-phase terminal\0eric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqVoltages([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("Double array of symmetrical component currents into each 3-phase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqCurrents([out, retval] VARIANT* Value);
    [propget, id(0x0000000E), helpstring("Double array of sequence powers into each 3-phase teminal\0-phase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqPowers([out, retval] VARIANT* Value);
    [propget, id(0x0000000F), helpstring("Boolean indicating that element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Enabled([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x0000000F), helpstring("Boolean indicating that element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Enabled([in] VARIANT_BOOL Value);
    [propget, id(0x00000010), helpstring("Normal ampere rating\0at element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormalAmps([out, retval] double* Value);
    [propput, id(0x00000010), helpstring("Normal ampere rating\0at element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormalAmps([in] double Value);
    [propget, id(0x00000011), helpstring("Emergency Ampere Rating\0element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergAmps([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Emergency Ampere Rating\0element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergAmps([in] double Value);
    [id(0x00000012), helpstring("Open the specified terminal and phase, if non-zero.  Else all conductors at terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Open([in] long Term, [in] long Phs);
    [id(0x00000013), helpstring("Close the specified terminal and phase, if non-zero.  Else all conductors at terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Close([in] long Term, [in] long Phs);
    [id(0x00000014), helpstring("Boolean indicating if the specified terminal and, optionally, phase is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsOpen([in] long Term, [in] long Phs, [out, retval] VARIANT_BOOL* Value);
    [propget, id(0x00000015), helpstring("Number of Properties this Circuit Element.\0l and, optionally, phase is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumProperties([out, retval] long* Value);
    [propget, id(0x00000016), helpstring("Variant array containing all property names of the active device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllPropertyNames([out, retval] VARIANT* Value);
    [propget, id(0x00000017), helpstring("Residual currents for each terminal: (mag, angle)\0 active device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Residuals([out, retval] VARIANT* Value);
    [propget, id(0x00000018), helpstring("YPrim matrix, column order, complex numbers (paired)\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Yprim([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Display name of the object (not necessarily unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DisplayName([out, retval] BSTR* Value);
    [propput, id(0x000000C9), helpstring("Display name of the object (not necessarily unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DisplayName([in] BSTR Value);
    [propget, id(0x000000CA), helpstring("Pointer to this object\0ect (not necessarily unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Handle([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("globally unique identifier for this object\0 unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GUID([out, retval] BSTR* Value);
    [propget, id(0x000000CC), helpstring("This element has a SwtControl attached.\0ct\0 unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall HasSwitchControl([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CD), helpstring("This element has a CapControl or RegControl attached.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall HasVoltControl([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CE), helpstring("Name of the Energy Meter this element is assigned to.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EnergyMeter([out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Full name of the controller attached to this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Controller([out, retval] BSTR* Value);
    [propget, id(0x000000D0), helpstring("Complex double array of Sequence Voltage for all terminals of active circuit element.")]
    HRESULT _stdcall CplxSeqVoltages([out, retval] VARIANT* Value);
    [propget, id(0x000000D1), helpstring("Complex double array of Sequence Currents for all conductors of all terminals of active circuit element.")]
    HRESULT _stdcall CplxSeqCurrents([out, retval] VARIANT* Value);
    [propget, id(0x000000D2), helpstring("Variant array of strings listing all the published variable names, if a PCElement. Otherwise, null string.")]
    HRESULT _stdcall AllVariableNames([out, retval] VARIANT* Value);
    [propget, id(0x000000D3), helpstring("Variant array of doubles. Values of state variables of active element if PC element.")]
    HRESULT _stdcall AllVariableValues([out, retval] VARIANT* Value);
    [propget, id(0x000000D4), helpstring("For PCElement, get the value of a variable by name. If Code>0 Then no variable by this name or not a PCelement.")]
    HRESULT _stdcall Variable([in] BSTR MyVarName, [out] long* Code, [out, retval] double* Value);
    [propget, id(0x000000D5), helpstring("For PCElement, get the value of a variable by integer index.")]
    HRESULT _stdcall Variablei([in] long Idx, [out] long* Code, [out, retval] double* Value);
  };

  [
    uuid(B521E339-8ED2-4BD6-9AEB-FD349CA8D8E3),
    version(1.0),
    helpstring("Dispatch interface for Errror Object\0ect\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IError: IDispatch
  {
    [propget, id(0x00000001), helpstring("Error Number\0the controller attached to this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Number([out, retval] long* Number);
    [propget, id(0x00000002), helpstring("Description of error for last operation\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Description([out, retval] BSTR* Description);
  };

  [
    uuid(32441C6D-7A27-4164-B5B0-FA054300C217),
    version(1.0),
    helpstring("Dispatch interface for Circuit Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface ICircuit: IDispatch
  {
    [propget, id(0x00000001), helpstring("Name of the active circuit.\0t operation\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propget, id(0x00000002), helpstring("Number of CktElements in the circuit.\0n\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumCktElements([out, retval] long* Value);
    [propget, id(0x00000003), helpstring("Total number of Buses in the circuit.\0n\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumBuses([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Total number of nodes in the circuit.\0n\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumNodes([out, retval] long* Value);
    [propget, id(0x00000005), helpstring("Collection of Buses in the circuit. Index may be string or integer index (0 based).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Buses([in] VARIANT Index, [out, retval] IBus** Value);
    [propget, id(0x00000006), helpstring("Collection of CktElements in Circuit\0ndex may be string or integer index (0 based).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CktElements([in] VARIANT Idx, [out, retval] ICktElement** Value);
    [propget, id(0x00000007), helpstring("Total losses in active circuit, complex number (two-element array of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Losses([out, retval] VARIANT* Value);
    [propget, id(0x00000008), helpstring("Complex total line losses in the circuit\0umber (two-element array of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LineLosses([out, retval] VARIANT* Value);
    [propget, id(0x00000009), helpstring("Complex losses in all transformers designated to substations.\0ray of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SubstationLosses([out, retval] VARIANT* Value);
    [propget, id(0x0000000A), helpstring("Total power, watts delivered to the circuit\0d to substations.\0ray of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TotalPower([out, retval] VARIANT* Value);
    [propget, id(0x0000000B), helpstring("Complex array of all bus, node voltages from most recent solution\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusVolts([out, retval] VARIANT* Value);
    [propget, id(0x0000000C), helpstring("Array of magnitudes (doubles) of voltages at all buses\0t solution\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusVmag([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("Vaiant array of strings containing Full Name of all elements.\0ion\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllElementNames([out, retval] VARIANT* Value);
    [propget, id(0x0000000E), helpstring("Return an interface to the active circuit element\0l elements.\0ion\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveElement([out, retval] ICktElement** Value);
    [id(0x0000000F), helpstring("Disable a circuit element by name (removes from circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Disable([in] BSTR Name);
    [id(0x00000010), helpstring("Activate (enable) a disabled device.\0moves from circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Enable([in] BSTR Name);
    [propget, id(0x00000011), helpstring("Return an interface to the Solution object.\0rom circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Solution([out, retval] ISolution** Value);
    [propget, id(0x00000012), helpstring("Return an interface to the active bus.\0ect.\0rom circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveBus([out, retval] IBus** Value);
    [id(0x00000013), helpstring("Sets the first Power Conversion (PC) element to be the active element.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FirstPCElement([out, retval] long* Value);
    [id(0x00000014), helpstring("Gets next PC Element.  Returns 0 if no more.\0to be the active element.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NextPCElement([out, retval] long* Value);
    [id(0x00000015), helpstring("Sets the first Power Delivery (PD) element to be the active element.\0.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FirstPDElement([out, retval] long* Value);
    [id(0x00000016), helpstring("Gets next PD Element. Returns 0 if no more.\0o be the active element.\0.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NextPDElement([out, retval] long* Value);
    [propget, id(0x00000017), helpstring("Array of strings containing names of all buses in circuit (see AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusNames([out, retval] VARIANT* Value);
    [propget, id(0x00000018), helpstring("Array of total losses (complex) in each circuit element\0t (see AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllElementLosses([out, retval] VARIANT* Value);
    [id(0x00000019), helpstring("Force all Meters and Monitors to take a sample.\0element\0t (see AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample(void);
    [id(0x0000001A), helpstring("Force all meters and monitors to save their current buffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SaveSample(void);
    [propget, id(0x0000001B), helpstring("Returns interface to Monitors collection.\0r current buffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Monitors([out, retval] IMonitors** Value);
    [propget, id(0x0000001C), helpstring("Returns interface to Meters (EnergyMeter) collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Meters([out, retval] IMeters** Value);
    [propget, id(0x0000001D), helpstring("Returns a Generators Object interface\0er) collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Generators([out, retval] IGenerators** Value);
    [propget, id(0x0000001E), helpstring("Returns interface to Settings interface.\0 collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Settings([out, retval] ISettings** Value);
    [propget, id(0x0000001F), helpstring("Returns Interface to Lines collection.\0.\0 collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Lines([out, retval] ILines** Value);
    [id(0x00000020), helpstring("Sets the Active Circuit Element using the full object name (e.g. \"generator.g1\"). Returns -1 if not found. Else index to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveElement([in] BSTR FullName, [out, retval] long* Value);
    [id(0x00000021)]
    HRESULT _stdcall Capacity([in] double Start, [in] double Increment, [out, retval] double* Value);
    [id(0x00000022), helpstring("Sets Active bus by name.  Returns bus index (zero based) compatible with AllBusNames and Buses collection.\0Else index to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveBus([in] BSTR BusName, [out, retval] long* Value);
    [id(0x00000024), helpstring("Sets ActiveBus by Integer value.  Returns 0 if OK.\0ased) compatible with AllBusNames and Buses collection.\0Else index to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveBusi([in] long BusIndex, [out, retval] long* Value);
    [propget, id(0x00000023), helpstring("Double Array of all bus voltages (each node) magnitudes in Per unit\0with AllBusNames and Buses collection.\0Else index to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusVmagPu([out, retval] VARIANT* Value);
    [propget, id(0x00000025), helpstring("Variant array of strings containing full name of each node in system in same order as returned by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeNames([out, retval] VARIANT* Value);
    [propget, id(0x00000026), helpstring("System Y matrix (after a solution has been performed)\0node in system in same order as returned by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SystemY([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Interface to the main Control Queue\0s been performed)\0node in system in same order as returned by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CtrlQueue([out, retval] ICtrlQueue** Value);
    [propget, id(0x000000CA), helpstring("Returns distance from each bus to parent EnergyMeter. Corresponds to sequence in AllBusNames.\0 by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusDistances([out, retval] VARIANT* Value);
    [propget, id(0x000000CB), helpstring("Returns an array of distances from parent EnergyMeter for each Node. Corresponds to AllBusVMag sequence.\0olts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeDistances([out, retval] VARIANT* Value);
    [propget, id(0x000000CC), helpstring("Returns Array of doubles represent voltage magnitudes for nodes on the specified phase.\0usVMag sequence.\0olts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeVmagByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000CD), helpstring("Returns array of per unit voltage magnitudes for each node by phase\0he specified phase.\0usVMag sequence.\0olts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeVmagPUByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("Returns an array of doubles representing the distances to parent EnergyMeter. Sequence of array corresponds to other node ByPhase properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeDistancesByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000CF), helpstring("Return variant array of strings of the node names for the By Phase criteria. Sequence corresponds to other ByPhase properties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeNamesByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000D0), helpstring("Returns interface to Load element interface\0names for the By Phase criteria. Sequence corresponds to other ByPhase properties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Loads([out, retval] ILoads** Value);
    [id(0x000000D1), helpstring("Sets First element of active class to be the Active element in the active circuit. Returns 0 if none.\0ther ByPhase properties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FirstElement([out, retval] long* Value);
    [id(0x000000D2), helpstring("Sets the next element of the active class to be the active element in the active circuit. Returns 0 if no more elements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NextElement([out, retval] long* Value);
    [id(0x000000D3), helpstring("Sets the active class by name.  Use FirstElement, NextElement to iterate through the class. Returns -1 if fails.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveClass([in] BSTR ClassName, [out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("Returns Interface to the Active DSS object, which could be either a circuit element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveDSSElement([out, retval] IDSSElement** Value);
    [propget, id(0x000000D5), helpstring("Returns interface to the Active Circuit element (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveCktElement([out, retval] ICktElement** Value);
    [propget, id(0x000000D6), helpstring("Returns interface to active class.\0cuit element (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveClass([out, retval] IActiveClass** Value);
    [propget, id(0x000000D7), helpstring("Returns interface to Transformers collection\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Transformers([out, retval] ITransformers** Value);
    [propget, id(0x000000D8), helpstring("Returns interface to SwtControls collection.\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwtControls([out, retval] ISwtControls** Value);
    [propget, id(0x000000D9), helpstring("Returns interface to CapControls collection\0\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CapControls([out, retval] ICapControls** Value);
    [propget, id(0x000000DA), helpstring("Returns interfact to RegControls collection\0\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegControls([out, retval] IRegControls** Value);
    [propget, id(0x000000DB), helpstring("Interface to the active circuit's Capacitors collection.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capacitors([out, retval] ICapacitors** Value);
    [propget, id(0x000000DC), helpstring("Interface to the active circuit's topology object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Topology([out, retval] ITopology** Value);
    [propget, id(0x000000DD), helpstring("Interface to Sensors in the Active Circuit.")]
    HRESULT _stdcall Sensors([out, retval] Sensors** Value);
    [id(0x000000DE)]
    HRESULT _stdcall UpdateStorage(void);
  };

  [
    uuid(E5B78C35-88F8-495F-8CD1-EBB5D90ED228),
    version(1.0),
    helpstring("Dispatch interface for Bus Object\0ect\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IBus: IDispatch
  {
    [propget, id(0x00000001), helpstring("Name of Bus\0 the active circuit's topology object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Name);
    [propget, id(0x00000002), helpstring("Number of Nodes this bus.\0rcuit's topology object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumNodes([out, retval] long* NumNodes);
    [propget, id(0x00000003), helpstring("Complex array of voltages at this bus.\0ogy object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Voltages([out, retval] VARIANT* Voltages);
    [propget, id(0x00000004), helpstring("Double Array of sequence voltages at this bus.\0ct.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqVoltages([out, retval] VARIANT* SeqVoltages);
    [propget, id(0x00000005), helpstring("Integer Array of Node Numbers defined at the bus.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Nodes([out, retval] VARIANT* Nodes);
    [propget, id(0x00000006), helpstring("Open circuit voltage; Complex array.\0 at the bus.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Voc([out, retval] VARIANT* Voc);
    [propget, id(0x00000007), helpstring("Short circuit currents at bus; Complex Array.\0us.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Isc([out, retval] VARIANT* Isc);
    [propget, id(0x00000008), helpstring("Complex Array of pu voltages at the bus.\0ray.\0us.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall puVoltages([out, retval] VARIANT* Value);
    [propget, id(0x00000009), helpstring("Base voltage at bus in kV\0es at the bus.\0ray.\0us.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kVBase([out, retval] double* Value);
    [propget, id(0x0000000A), helpstring("Complex array of Zsc matrix at bus. Column by column.\0n.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZscMatrix([out, retval] VARIANT* Value);
    [propget, id(0x0000000B), helpstring("Complex Positive-Sequence short circuit impedance at bus..\0tiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Zsc1([out, retval] VARIANT* Value);
    [propget, id(0x0000000C), helpstring("Complex Zero-Sequence short circuit impedance at bus.\0us..\0tiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Zsc0([out, retval] VARIANT* Value);
    [id(0x0000000D), helpstring("Recomputes Zsc for active bus for present circuit configuration.\0ement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZscRefresh([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x0000000E), helpstring("Complex array of Ysc matrix at bus. Column by column.\0iguration.\0ement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall YscMatrix([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("False=0 else True. Indicates whether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Coorddefined([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CA), helpstring("X Coordinate for bus (double)\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall x([out, retval] double* Value);
    [propput, id(0x000000CA), helpstring("X Coordinate for bus (double)\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall x([in] double Value);
    [propget, id(0x000000CB), helpstring("Y coordinate for bus(double)\0\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall y([out, retval] double* Value);
    [propput, id(0x000000CB), helpstring("Y coordinate for bus(double)\0\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall y([in] double Value);
    [propget, id(0x000000CC), helpstring("Distance from energymeter (if non-zero)\0oordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Distance([out, retval] double* Value);
    [id(0x000000CD), helpstring("Returns a unique node number at the active bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GetUniqueNodeNumber([in] long StartNumber, [out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Complex Double array of Sequence Voltages (0, 1, 2) at this Bus.")]
    HRESULT _stdcall CplxSeqVoltages([out, retval] VARIANT* Value);
  };

  [
    uuid(14644AD0-4909-48FF-B624-24E8C38D1AED),
    version(1.0),
    helpstring("Dispatch interface for DSSMain Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IDSS: IDispatch
  {
    [propget, id(0x00000001), helpstring("Number of Circuits currently defined\0ctive bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumCircuits([out, retval] long* Value);
    [propget, id(0x00000002), helpstring("Collection of Circuit objects\0efined\0ctive bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Circuits([in] VARIANT Idx, [out, retval] ICircuit** Value);
    [propget, id(0x00000003), helpstring("Returns interface to the active circuit.\0e bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveCircuit([out, retval] ICircuit** Value);
    [propget, id(0x00000004), helpstring("Returns the DSS Text (command-result) interface.\0 avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Text([out, retval] IText** Value);
    [propget, id(0x00000005), helpstring("Returns Error interface.\0mand-result) interface.\0 avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Error([out, retval] IError** Value);
    [id(0x00000006), helpstring("Make a new circuit and return interface to active circuit.\0e collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NewCircuit([in] BSTR Name, [out, retval] ICircuit** Value);
    [id(0x00000007), helpstring("Clears all circuit definitions.\0terface to active circuit.\0e collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ClearAll(void);
    [id(0x00000008), helpstring("Shows non-MDI child form of the Main DSS Edit Form\0ircuit.\0e collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ShowPanel(void);
    [id(0x00000009), helpstring("Validate the user and start the DSS. Returns TRUE if successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Start([in] long code, [out, retval] VARIANT_BOOL* Value);
    [propget, id(0x0000000A), helpstring("Get version string for the DSS.\0DSS. Returns TRUE if successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Version([out, retval] BSTR* Value);
    [propget, id(0x0000000B), helpstring("Gets interface to the DSS Progress Meter\0rns TRUE if successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DSSProgress([out, retval] IDSSProgress** Value);
    [propget, id(0x0000000C), helpstring("List of DSS intrinsic classes (names of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Classes([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("List of user-defined classes\0 (names of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UserClasses([out, retval] VARIANT* Value);
    [propget, id(0x0000000E), helpstring("Number of DSS intrinsic classes\0ames of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumClasses([out, retval] long* Value);
    [propget, id(0x0000000F), helpstring("Number of user-defined classes\0\0ames of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumUserClasses([out, retval] long* Value);
    [propget, id(0x00000011), helpstring("DSS Data File Path.  Default path for reports, etc. from DSS\0ul.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DataPath([out, retval] BSTR* Value);
    [propput, id(0x00000011), helpstring("DSS Data File Path.  Default path for reports, etc. from DSS\0ul.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DataPath([in] BSTR Value);
    [id(0x00000012), helpstring("Resets DSS Initialization for restarts, etc from applets\0DSS\0ul.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Reset(void);
    [propget, id(0x00000014), helpstring("Default is TRUE. Use this to set to FALSE; Cannot reset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowForms([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000014), helpstring("Default is TRUE. Use this to set to FALSE; Cannot reset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowForms([in] VARIANT_BOOL Value);
    [propget, id(0x000000C9), helpstring("Returns the path name for the default text editor.\0eset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultEditor([out, retval] BSTR* Value);
    [propget, id(0x000000CA), helpstring("Returns interface to the active class.\0ext editor.\0eset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveClass([out, retval] IActiveClass** Value);
    [id(0x000000CB), helpstring("Sets the Active DSS Class for use with ActiveClass interface. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveClass([in] BSTR ClassName, [out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Interface to DSSGraph plotting routines.\0tiveClass interface. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Plot([out, retval] IPlot** Value);
    [propget, id(0x000000CD), helpstring("Interface to DSS Executive commands and options\0ss interface. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Executive([out, retval] IDSS_Executive** Value);
    [propget, id(0x000000CE), helpstring("Interface to the DSS Events")]
    HRESULT _stdcall Events([out, retval] IDSSEvents** Value);
  };

  [
    uuid(F2332365-962A-4DF4-9D1E-218E0B0F2CEF),
    version(1.0),
    helpstring("Dispatch interface for Solution Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface ISolution: IDispatch
  {
    [id(0x00000001), helpstring("Execute solution for present solution mode.\0ons\0ss interface. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Solve(void);
    [propget, id(0x00000002), helpstring("Set present solution mode (by a text code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([out, retval] long* Mode);
    [propput, id(0x00000002), helpstring("Set present solution mode (by a text code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([in] long Mode);
    [propget, id(0x00000003), helpstring("Set the Frequency for next solution\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Frequency([out, retval] double* Frequency);
    [propput, id(0x00000003), helpstring("Set the Frequency for next solution\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Frequency([in] double Frequency);
    [propget, id(0x00000004), helpstring("Set Hour for time series solutions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Hour([out, retval] long* Hour);
    [propput, id(0x00000004), helpstring("Set Hour for time series solutions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Hour([in] long Hour);
    [propget, id(0x00000005), helpstring("Seconds from top of the hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Seconds([out, retval] double* Seconds);
    [propput, id(0x00000005), helpstring("Seconds from top of the hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Seconds([in] double Seconds);
    [propget, id(0x00000006), helpstring("Time step size in sec\0e hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepSize([out, retval] double* StepSize);
    [propput, id(0x00000006), helpstring("Time step size in sec\0e hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepSize([in] double StepSize);
    [propget, id(0x00000007), helpstring("Set year for planning studies\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Year([out, retval] long* Year);
    [propput, id(0x00000007), helpstring("Set year for planning studies\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Year([in] long Year);
    [propget, id(0x00000008), helpstring("Default load multiplier applied to all non-fixed loads\0p)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadMult([out, retval] double* LoadMult);
    [propput, id(0x00000008), helpstring("Default load multiplier applied to all non-fixed loads\0p)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadMult([in] double LoadMult);
    [propget, id(0x00000009), helpstring("Number of iterations taken for last solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Iterations([out, retval] long* Iterations);
    [propget, id(0x0000000A), helpstring("Max allowable iterations.\0 for last solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxIterations([out, retval] long* MaxIterations);
    [propput, id(0x0000000A), helpstring("Max allowable iterations.\0 for last solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxIterations([in] long MaxIterations);
    [propget, id(0x0000000B), helpstring("Solution convergence tolerance.\0ast solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tolerance([out, retval] double* Tolerance);
    [propput, id(0x0000000B), helpstring("Solution convergence tolerance.\0ast solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tolerance([in] double Tolerance);
    [propget, id(0x0000000C), helpstring("Number of solutions to perform for Monte Carlo and time series simulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Number([out, retval] long* Number);
    [propput, id(0x0000000C), helpstring("Number of solutions to perform for Monte Carlo and time series simulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Number([in] long Number);
    [propget, id(0x0000000D), helpstring("Randomization mode for random variables \"Gaussian\" or \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Random([out, retval] long* Random);
    [propput, id(0x0000000D), helpstring("Randomization mode for random variables \"Gaussian\" or \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Random([in] long Random);
    [propget, id(0x0000000E), helpstring("ID (text) of the present solution mode\0 \"Gaussian\" or \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ModeID([out, retval] BSTR* Value);
    [propget, id(0x0000000F), helpstring("Load Model: {dssPowerFlow (default) | dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadModel([out, retval] long* Value);
    [propput, id(0x0000000F), helpstring("Load Model: {dssPowerFlow (default) | dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadModel([in] long Value);
    [propget, id(0x00000010), helpstring("Load-Duration Curve name for LD modes\0dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LDCurve([out, retval] BSTR* Value);
    [propput, id(0x00000010), helpstring("Load-Duration Curve name for LD modes\0dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LDCurve([in] BSTR Value);
    [propget, id(0x00000011), helpstring("Percent default  annual load growth rate\0Admittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall pctGrowth([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Percent default  annual load growth rate\0Admittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall pctGrowth([in] double Value);
    [propget, id(0x00000012), helpstring("Type of device to add in AutoAdd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AddType([out, retval] long* Value);
    [propput, id(0x00000012), helpstring("Type of device to add in AutoAdd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AddType([in] long Value);
    [propget, id(0x00000013), helpstring("Generator kW for AutoAdd mode\0dd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenkW([out, retval] double* Value);
    [propput, id(0x00000013), helpstring("Generator kW for AutoAdd mode\0dd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenkW([in] double Value);
    [propget, id(0x00000014), helpstring("PF for generators in AutoAdd mode\0ode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenPF([out, retval] double* Value);
    [propput, id(0x00000014), helpstring("PF for generators in AutoAdd mode\0ode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenPF([in] double Value);
    [propget, id(0x00000015), helpstring("Capacitor kvar for adding capacitors in AutoAdd mode\0lt) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capkvar([out, retval] double* Value);
    [propput, id(0x00000015), helpstring("Capacitor kvar for adding capacitors in AutoAdd mode\0lt) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capkvar([in] double Value);
    [propget, id(0x00000016), helpstring("Base Solution algorithm: {dssNormalSolve | dssNewtonSolve}\0dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Algorithm([out, retval] long* Value);
    [propput, id(0x00000016), helpstring("Base Solution algorithm: {dssNormalSolve | dssNewtonSolve}\0dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Algorithm([in] long Value);
    [propget, id(0x00000017), helpstring("{dssStatic* | dssEvent | dssTime}  Modes for control devices\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlMode([out, retval] long* Value);
    [propput, id(0x00000017), helpstring("{dssStatic* | dssEvent | dssTime}  Modes for control devices\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlMode([in] long Value);
    [propget, id(0x00000018), helpstring("Default Multiplier applied to generators (like LoadMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenMult([out, retval] double* Value);
    [propput, id(0x00000018), helpstring("Default Multiplier applied to generators (like LoadMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenMult([in] double Value);
    [propget, id(0x00000019), helpstring("Default daily load shape (defaults to \"Default\")\0adMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultDaily([out, retval] BSTR* Value);
    [propput, id(0x00000019), helpstring("Default daily load shape (defaults to \"Default\")\0adMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultDaily([in] BSTR Value);
    [propget, id(0x0000001A), helpstring("Default Yearly load shape (defaults to \"Default\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultYearly([out, retval] BSTR* Value);
    [propput, id(0x0000001A), helpstring("Default Yearly load shape (defaults to \"Default\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultYearly([in] BSTR Value);
    [propget, id(0x0000001B), helpstring("Array of strings containing the Event Log\0fault\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EventLog([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Hour as a double, including fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall dblHour([out, retval] double* Value);
    [propput, id(0x000000C9), helpstring("Hour as a double, including fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall dblHour([in] double Value);
    [propput, id(0x000000CA), helpstring("Set Stepsize in minutes\0ing fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepsizeMin([in] double Param1);
    [propput, id(0x000000CB), helpstring("Set Stepsize in Hr\0utes\0ing fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepsizeHr([in] double Param1);
    [propget, id(0x000000CC), helpstring("Value of the control iteration counter\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlIterations([out, retval] long* Value);
    [propput, id(0x000000CC), helpstring("Value of the control iteration counter\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlIterations([in] long Value);
    [propget, id(0x000000CD), helpstring("Maximum allowable control iterations\0r\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxControlIterations([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Maximum allowable control iterations\0r\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxControlIterations([in] long Value);
    [id(0x000000CE), helpstring("Sample controls and then process the control queue for present control mode and dispatch control actions\0.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample_DoControlActions(void);
    [id(0x000000CF), helpstring("Executes status check on all fault objects defined in the circuit.\0rol mode and dispatch control actions\0.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CheckFaultStatus(void);
    [id(0x000000D0), helpstring("Execute the snapshot power flow routine in the DSS that solves at the present state with control actions\0.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolveSnap(void);
    [id(0x000000D1), helpstring("Executes a direct solution from the system Y matrix, ignoring compensation currents of loads, generators (includes Yprim only)\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolveDirect(void);
    [id(0x000000D2), helpstring("Solves using present power flow method. Iterative solution rather than direct solution.\0oads, generators (includes Yprim only)\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolvePflow(void);
    [id(0x000000D3), helpstring("Similar to SolveSnap except no control actions are checked or executed\0direct solution.\0oads, generators (includes Yprim only)\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolveNoControl(void);
    [id(0x000000D4), helpstring("Executes a power flow solution (SolveNoControl) plus executes a CheckControlActions that executes any pending control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolvePlusControl(void);
    [id(0x000000D5), helpstring("Initializes some variables for snap shot power flow. SolveSnap does this automatically.\0 executes any pending control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall InitSnap(void);
    [id(0x000000D6), helpstring("The normal process for sampling and executing Control Actions and Fault Status and rebuilds Y if necessary.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CheckControls(void);
    [id(0x000000D7), helpstring("Executes a sampling of all intrinsic control devices, which push control actions onto the control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleControlDevices(void);
    [id(0x000000D8), helpstring("Pops control actions off the control queue and dispatches to the proper control element\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DoControlActions(void);
    [id(0x000000D9), helpstring("Force building of the System Y matrix\0ueue and dispatches to the proper control element\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall BuildYMatrix([in] long BuildOption, [in] long AllocateVI);
    [propget, id(0x000000DA), helpstring("Flag that indicates if elements of the System Y have been changed by recent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SystemYChanged([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000DB), helpstring("Flag to indicate whether the circuit solution converged\0n changed by recent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Converged([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000DB), helpstring("Flag to indicate whether the circuit solution converged\0n changed by recent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Converged([in] VARIANT_BOOL Value);
    [propget, id(0x000000DC), helpstring("Total iterations including control iterations for most recent solution.\0ent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Totaliterations([out, retval] long* Value);
    [propget, id(0x000000DD), helpstring("Max number of iterations required to converge at any control iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MostIterationsDone([out, retval] long* Value);
    [propget, id(0x000000DE), helpstring("Flag indicating the control actions are done.")]
    HRESULT _stdcall ControlActionsDone([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000DE)]
    HRESULT _stdcall ControlActionsDone([in] VARIANT_BOOL Value);
  };

  [
    uuid(5C339E44-C583-445C-91D1-3B1E49CAD6B0),
    version(1.0),
    helpstring("Dispatch interface for Monitors Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IMonitors: IDispatch
  {
    [propget, id(0x00000002), helpstring("Array of all Monitor Names\0quired to converge at any control iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000003), helpstring("Sets the first Monitor active.  Returns 0 if no monitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Sets next monitor active.  Returns 0 if no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [id(0x00000005), helpstring("Resets active Monitor object.\0urns 0 if no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Reset(void);
    [id(0x00000006), helpstring("Resets all Monitor Objects\0t.\0urns 0 if no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ResetAll(void);
    [id(0x00000007), helpstring("Causes active Monitor to take a sample.\0no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample(void);
    [id(0x00000008), helpstring("Causes active monitor to save its current buffer to CSV File\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Save(void);
    [id(0x00000009), helpstring("Converts monitor file to text and displays with text editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Show(void);
    [propget, id(0x0000000A), helpstring("Name of CSV file associated with active Monitor.\0ext editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FileName([out, retval] BSTR* Value);
    [propget, id(0x0000000B), helpstring("Set Monitor mode (bitmask integer - see DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([out, retval] long* Value);
    [propput, id(0x0000000B), helpstring("Set Monitor mode (bitmask integer - see DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([in] long Value);
    [propget, id(0x00000001), helpstring("Sets the active Monitor object by name\0 DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x00000001), helpstring("Sets the active Monitor object by name\0 DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x0000000C), helpstring("Byte Array containing monitor stream values\0Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ByteStream([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("Number of Samples in Monitor at Present\0ues\0Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleCount([out, retval] long* Value);
    [id(0x000000C9), helpstring("Causes all Monitors to take a sample of the present state\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleAll(void);
    [id(0x000000CA), helpstring("Save all Monitors\0s to take a sample of the present state\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SaveAll(void);
    [propget, id(0x000000CB), helpstring("Number of Monitors\0 to take a sample of the present state\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(86705B6C-352A-47F8-A24B-78B750EC3859),
    version(1.0),
    helpstring("Dispatch interface for Meters Object\0t\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IMeters: IDispatch
  {
    [propget, id(0x00000002), helpstring("Array of all energy Meter names\0mple of the present state\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000003), helpstring("Set the first energy Meter active. Returns 0 if none.\0ate\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Sets the next energy Meter active.  Returns 0 if no more.\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x00000005), helpstring("Array of strings containing the names of the registers.\0.\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterNames([out, retval] VARIANT* Value);
    [propget, id(0x00000006), helpstring("Array of all the values contained in the Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterValues([out, retval] VARIANT* Value);
    [id(0x00000007), helpstring("Resets registers of active Meter.\0in the Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Reset(void);
    [id(0x00000008), helpstring("Resets registers of all Meter objects.\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ResetAll(void);
    [id(0x00000009), helpstring("Forces active Meter to take a sample.\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample(void);
    [id(0x0000000A), helpstring("Saves meter register values.\0 sample.\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Save(void);
    [propget, id(0x0000000C), helpstring("Set a meter to be active by name.\0le.\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x0000000C), helpstring("Set a meter to be active by name.\0le.\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x00000001), helpstring("Totals of all registers of all meters\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Totals([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Array of doubles to set values of Peak Current property\0 for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Peakcurrent([out, retval] VARIANT* Value);
    [propput, id(0x000000C9), helpstring("Array of doubles to set values of Peak Current property\0 for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Peakcurrent([in] VARIANT Value);
    [propget, id(0x000000CA), helpstring("Set the magnitude of the real part of the Calculated Current (normally determined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CalcCurrent([out, retval] VARIANT* Value);
    [propput, id(0x000000CA), helpstring("Set the magnitude of the real part of the Calculated Current (normally determined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CalcCurrent([in] VARIANT Value);
    [propget, id(0x000000CB), helpstring("Array of doubles: set the phase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllocFactors([out, retval] VARIANT* Value);
    [propput, id(0x000000CB), helpstring("Array of doubles: set the phase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllocFactors([in] VARIANT Value);
    [propget, id(0x000000CC), helpstring("Set Name of metered element\0ase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredElement([out, retval] BSTR* Value);
    [propput, id(0x000000CC), helpstring("Set Name of metered element\0ase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredElement([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("set Number of Metered Terminal\0 allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredTerminal([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("set Number of Metered Terminal\0 allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredTerminal([in] long Value);
    [propget, id(0x000000CE), helpstring("Global Flag in the DSS to indicate if Demand Interval (DI) files have been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DIFilesAreOpen([out, retval] VARIANT_BOOL* Value);
    [id(0x000000CF), helpstring("Causes all EnergyMeter objects to take a sample at the present time\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleAll(void);
    [id(0x000000D0), helpstring("Save All EnergyMeter objects\0s to take a sample at the present time\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SaveAll(void);
    [id(0x000000D1), helpstring("Open Demand Interval (DI) files\0o take a sample at the present time\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall OpenAllDIFiles(void);
    [id(0x000000D2), helpstring("Close All Demand Interval Files ( Necessary at the end of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CloseAllDIFiles(void);
    [propget, id(0x000000D3), helpstring("Number of zone end elements in the active meter zone.\0 of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CountEndElements([out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("Variant array of names of all zone end elements.\0one.\0 of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllEndElements([out, retval] VARIANT* Value);
    [propget, id(0x000000D5), helpstring("Number of Energy Meters in the Active Circuit\0s.\0one.\0 of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000D6), helpstring("Wide string list of all branches in zone of the active energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBranchesInZone([out, retval] VARIANT* Value);
    [propget, id(0x000000D7), helpstring("Number of branches in Active energymeter zone.\0 active energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CountBranches([out, retval] long* Value);
  };

  [
    uuid(2D9B7548-D03E-478A-9FEA-9FC4033C793E),
    version(1.0),
    helpstring("Dispatch interface for Generators Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IGenerators: IDispatch
  {
    [propget, id(0x00000002), helpstring("Array of names of all Generator objects.\0zone.\0 active energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000003), helpstring("Array of Names of all generator energy meter registers\0energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterNames([out, retval] VARIANT* Value);
    [propget, id(0x00000004), helpstring("Array of valus in generator energy meter registers.\0rs\0energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterValues([out, retval] VARIANT* Value);
    [propget, id(0x00000005), helpstring("Sets first Generator to be active.  Returns 0 if none.\0energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000006), helpstring("Sets next Generator to be active.  Returns 0 if no more.\0ergymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x00000008), helpstring("Indicates whether the generator is forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForcedON([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000008), helpstring("Indicates whether the generator is forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForcedON([in] VARIANT_BOOL Value);
    [propget, id(0x00000009), helpstring("Sets a generator active by name.\0s forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x00000009), helpstring("Sets a generator active by name.\0s forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000C9), helpstring("Voltage base for the active generator, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000C9), helpstring("Voltage base for the active generator, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000CA), helpstring("kW output for the active generator\0or, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kW([out, retval] double* Value);
    [propput, id(0x000000CA), helpstring("kW output for the active generator\0or, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kW([in] double Value);
    [propget, id(0x000000CB), helpstring("kvar output for the active generator\0, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000CB), helpstring("kvar output for the active generator\0, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kvar([in] double Value);
    [propget, id(0x000000CC), helpstring("Power factor (pos. = producing vars)\0, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PF([out, retval] double* Value);
    [propput, id(0x000000CC), helpstring("Power factor (pos. = producing vars)\0, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PF([in] double Value);
    [propget, id(0x000000CD), helpstring("Number of phases\0. = producing vars)\0, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Number of phases\0. = producing vars)\0, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([in] long Value);
    [propget, id(0x000000CE), helpstring("Number of Generator Objects in Active Circuit\0egardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(315C0C38-929C-4942-BDF8-6DA12D001B47),
    version(1.0),
    helpstring("Dispatch interface for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IDSSProgress: IDispatch
  {
    [propput, id(0x00000001), helpstring("Percent progress to indicate [0..100]\0Circuit\0egardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PctProgress([in] long Param1);
    [propput, id(0x00000002), helpstring("Caption to appear on the bottom of the DSS Progress form.\0other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Caption([in] BSTR Param1);
    [id(0x00000003), helpstring("Shows progress form with null caption and progress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Show(void);
    [id(0x00000004), helpstring("Closes (hides) DSS Progress form.\0ion and progress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Close(void);
  };

  [
    uuid(4E3928A0-8B75-4127-885F-F4AD6B3F4323),
    version(1.0),
    helpstring("Dispatch interface for Settings Object\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ISettings: IDispatch
  {
    [propget, id(0x00000001), helpstring("{True | False*} Designates whether to allow duplicate names of objects\0h criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowDuplicates([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000001), helpstring("{True | False*} Designates whether to allow duplicate names of objects\0h criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowDuplicates([in] VARIANT_BOOL Value);
    [propget, id(0x00000002), helpstring("{True | False*}  Locks Zones on energy meters to prevent rebuilding if a circuit change occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZoneLock([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000002), helpstring("{True | False*}  Locks Zones on energy meters to prevent rebuilding if a circuit change occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZoneLock([in] VARIANT_BOOL Value);
    [propput, id(0x00000003), helpstring("Sets all load allocation factors for all loads defined by XFKVA property to this value.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllocationFactors([in] double Param1);
    [propget, id(0x00000004), helpstring("List of Buses or (File=xxxx) syntax for the AutoAdd solution mode.\0perty to this value.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AutoBusList([out, retval] BSTR* Value);
    [propput, id(0x00000004), helpstring("List of Buses or (File=xxxx) syntax for the AutoAdd solution mode.\0perty to this value.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AutoBusList([in] BSTR Value);
    [propget, id(0x00000005), helpstring("{dssMultiphase * | dssPositiveSeq} IIndicate if the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CktModel([out, retval] long* Value);
    [propput, id(0x00000005), helpstring("{dssMultiphase * | dssPositiveSeq} IIndicate if the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CktModel([in] long Value);
    [propget, id(0x00000006), helpstring("Per Unit minimum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVminpu([out, retval] double* Value);
    [propput, id(0x00000006), helpstring("Per Unit minimum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVminpu([in] double Value);
    [propget, id(0x00000007), helpstring("Per Unit maximum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVmaxpu([out, retval] double* Value);
    [propput, id(0x00000007), helpstring("Per Unit maximum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVmaxpu([in] double Value);
    [propget, id(0x00000008), helpstring("Per Unit minimum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVminpu([out, retval] double* Value);
    [propput, id(0x00000008), helpstring("Per Unit minimum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVminpu([in] double Value);
    [propget, id(0x00000009), helpstring("Per Unit maximum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVmaxpu([out, retval] double* Value);
    [propput, id(0x00000009), helpstring("Per Unit maximum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVmaxpu([in] double Value);
    [propget, id(0x0000000A), helpstring("Weighting factor applied to UE register values.\0s.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEweight([out, retval] double* Value);
    [propput, id(0x0000000A), helpstring("Weighting factor applied to UE register values.\0s.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEweight([in] double Value);
    [propget, id(0x0000000B), helpstring("Weighting factor applied to Loss register values.\0\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossWeight([out, retval] double* Value);
    [propput, id(0x0000000B), helpstring("Weighting factor applied to Loss register values.\0\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossWeight([in] double Value);
    [propget, id(0x0000000C), helpstring("Array of Integers defining energy meter registers to use for computing UE\0ive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEregs([out, retval] VARIANT* Value);
    [propput, id(0x0000000C), helpstring("Array of Integers defining energy meter registers to use for computing UE\0ive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEregs([in] VARIANT Value);
    [propget, id(0x0000000D), helpstring("Integer array defining which energy meter registers to use for computing losses\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossRegs([out, retval] VARIANT* Value);
    [propput, id(0x0000000D), helpstring("Integer array defining which energy meter registers to use for computing losses\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossRegs([in] VARIANT Value);
    [propget, id(0x0000000E), helpstring("{True | False *} Gets value of trapezoidal integration flag in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Trapezoidal([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x0000000E), helpstring("{True | False *} Gets value of trapezoidal integration flag in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Trapezoidal([in] VARIANT_BOOL Value);
    [propget, id(0x0000000F), helpstring("Array of doubles defining the legal voltage bases in kV L-L\0in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageBases([out, retval] VARIANT* Value);
    [propput, id(0x0000000F), helpstring("Array of doubles defining the legal voltage bases in kV L-L\0in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageBases([in] VARIANT Value);
    [propget, id(0x00000010), helpstring("{True | False*} Denotes whether to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlTrace([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000010), helpstring("{True | False*} Denotes whether to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlTrace([in] VARIANT_BOOL Value);
    [propget, id(0x00000011), helpstring("Price Signal for the Circuit\0er to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceSignal([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Price Signal for the Circuit\0er to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceSignal([in] double Value);
    [propget, id(0x00000012), helpstring("Name of LoadShape object that serves as the source of price signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceCurve([out, retval] BSTR* Value);
    [propput, id(0x00000012), helpstring("Name of LoadShape object that serves as the source of price signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceCurve([in] BSTR Value);
  };

  [
    uuid(E1616BDB-589B-4E5D-A7CE-828ACD73E5D4),
    version(1.0),
    helpstring("Dispatch interface for Lines Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ILines: IDispatch
  {
    [propget, id(0x00000006), helpstring("Specify the name of the Line element to set it active.\0rice signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x00000006), helpstring("Specify the name of the Line element to set it active.\0rice signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x00000007), helpstring("Names of all Line Objects\0ne element to set it active.\0rice signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000008), helpstring("Invoking this property sets the first element active.  Returns 0 if no lines.  Otherwise, index of the line element.\0 some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000009), helpstring("Invoking this property advances to the next Line element active.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [id(0x0000000A), helpstring("Creates a new Line and makes it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall New([in] BSTR Name, [out, retval] long* Value);
    [propget, id(0x0000000B), helpstring("Name of bus for terminal 1.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus1([out, retval] BSTR* Value);
    [propput, id(0x0000000B), helpstring("Name of bus for terminal 1.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus1([in] BSTR Value);
    [propget, id(0x0000000C), helpstring("Name of bus for terminal 2.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus2([out, retval] BSTR* Value);
    [propput, id(0x0000000C), helpstring("Name of bus for terminal 2.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus2([in] BSTR Value);
    [propget, id(0x0000000D), helpstring("Name of LineCode object that defines the impedances.\0ement.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LineCode([out, retval] BSTR* Value);
    [propput, id(0x0000000D), helpstring("Name of LineCode object that defines the impedances.\0ement.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LineCode([in] BSTR Value);
    [propget, id(0x0000000E), helpstring("Length of line section in units compatible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Length([out, retval] double* Value);
    [propput, id(0x0000000E), helpstring("Length of line section in units compatible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Length([in] double Value);
    [propget, id(0x0000000F), helpstring("Number of Phases, this Line element.\0tible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([out, retval] long* Value);
    [propput, id(0x0000000F), helpstring("Number of Phases, this Line element.\0tible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([in] long Value);
    [propget, id(0x00000010), helpstring("Positive Sequence resistance, ohms per unit length.\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R1([out, retval] double* Value);
    [propput, id(0x00000010), helpstring("Positive Sequence resistance, ohms per unit length.\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R1([in] double Value);
    [propget, id(0x00000011), helpstring("Positive Sequence reactance, ohms per unit length.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X1([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Positive Sequence reactance, ohms per unit length.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X1([in] double Value);
    [propget, id(0x00000012), helpstring("Zero Sequence resistance, ohms per unit length.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R0([out, retval] double* Value);
    [propput, id(0x00000012), helpstring("Zero Sequence resistance, ohms per unit length.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R0([in] double Value);
    [propget, id(0x00000013), helpstring("Zero Sequence reactance ohms per unit length.\0.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X0([out, retval] double* Value);
    [propput, id(0x00000013), helpstring("Zero Sequence reactance ohms per unit length.\0.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X0([in] double Value);
    [propget, id(0x00000014), helpstring("Positive Sequence capacitance, nanofarads per unit length.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C1([out, retval] double* Value);
    [propput, id(0x00000014), helpstring("Positive Sequence capacitance, nanofarads per unit length.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C1([in] double Value);
    [propget, id(0x00000015), helpstring("Zero Sequence capacitance, nanofarads per unit length.\0th.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C0([out, retval] double* Value);
    [propput, id(0x00000015), helpstring("Zero Sequence capacitance, nanofarads per unit length.\0th.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C0([in] double Value);
    [propget, id(0x00000016), helpstring("Resistance matrix (full), ohms per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rmatrix([out, retval] VARIANT* Value);
    [propput, id(0x00000016), helpstring("Resistance matrix (full), ohms per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rmatrix([in] VARIANT Value);
    [propget, id(0x00000017)]
    HRESULT _stdcall Xmatrix([out, retval] VARIANT* Value);
    [propput, id(0x00000017)]
    HRESULT _stdcall Xmatrix([in] VARIANT Value);
    [propget, id(0x00000018)]
    HRESULT _stdcall Cmatrix([out, retval] VARIANT* Value);
    [propput, id(0x00000018)]
    HRESULT _stdcall Cmatrix([in] VARIANT Value);
    [propget, id(0x00000019), helpstring("Normal ampere rating of Line.\0 per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormAmps([out, retval] double* Value);
    [propput, id(0x00000019), helpstring("Normal ampere rating of Line.\0 per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormAmps([in] double Value);
    [propget, id(0x0000001A), helpstring("Emergency (maximum) ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergAmps([out, retval] double* Value);
    [propput, id(0x0000001A), helpstring("Emergency (maximum) ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergAmps([in] double Value);
    [propget, id(0x00000001), helpstring("Line geometry code\0 ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Geometry([out, retval] BSTR* Value);
    [propput, id(0x00000001), helpstring("Line geometry code\0 ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Geometry([in] BSTR Value);
    [propget, id(0x00000002), helpstring("Earth return resistance value used to compute line impedances at power frequency\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rg([out, retval] double* Value);
    [propput, id(0x00000002), helpstring("Earth return resistance value used to compute line impedances at power frequency\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rg([in] double Value);
    [propget, id(0x00000003), helpstring("Earth return reactance value used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xg([out, retval] double* Value);
    [propput, id(0x00000003), helpstring("Earth return reactance value used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xg([in] double Value);
    [propget, id(0x00000004), helpstring("Earth Resistivity, m-ohms\0ue used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rho([out, retval] double* Value);
    [propput, id(0x00000004), helpstring("Earth Resistivity, m-ohms\0ue used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rho([in] double Value);
    [propget, id(0x00000005), helpstring("Yprimitive: Does Nothing at present on Put; Dangerous\0dances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Yprim([out, retval] VARIANT* Value);
    [propput, id(0x00000005), helpstring("Yprimitive: Does Nothing at present on Put; Dangerous\0dances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Yprim([in] VARIANT Value);
    [propget, id(0x000000C9), helpstring("Number of customers on this line section.\0; Dangerous\0dances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumCust([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Total Number of customers served from this line section.\0ces at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TotalCust([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets Parent of the active Line to be the active line. Returns 0 if no parent or action fails.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Parent([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Number of Line objects in Active Circuit.\0ctive line. Returns 0 if no parent or action fails.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Line spacing code")]
    HRESULT _stdcall Spacing([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Line spacing code")]
    HRESULT _stdcall Spacing([in] BSTR Value);
  };

  [
    uuid(55055001-5EEC-4667-9CCA-63F3A60F31F3),
    version(1.0),
    helpstring("Interface for CtrlQueue Object\0ject\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ICtrlQueue: IDispatch
  {
    [id(0x00000065), helpstring("Clear control queue\0ts in Active Circuit.\0ctive line. Returns 0 if no parent or action fails.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ClearQueue(void);
    [id(0x00000067), helpstring("Delete a control action from the DSS control queue by referencing the handle of the action\0s.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delete([in] long ActionHandle);
    [propget, id(0x00000068), helpstring("Number of Actions on the current actionlist (that have been popped off the control queue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumActions([out, retval] long* Value);
    [propput, id(0x00000066), helpstring("Set the active action by index\0t actionlist (that have been popped off the control queue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Action([in] long Param1);
    [propget, id(0x00000069), helpstring("Code for the active action. Long integer code to tell the control device what to do\0ueue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActionCode([out, retval] long* Value);
    [propget, id(0x0000006A), helpstring("Handle (User defined) to device that must act on the pending action.\0ice what to do\0ueue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DeviceHandle([out, retval] long* Value);
    [id(0x0000006B), helpstring("Push a control action onto the DSS control queue by time, action code, and device handle (user defined). Returns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Push([in] long Hour, [in] double Seconds, [in] long ActionCode, [in] long DeviceHandle, [out, retval] long* Value);
    [id(0x0000006C), helpstring("Show entire control queue in CSV format\0ol queue by time, action code, and device handle (user defined). Returns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Show(void);
    [id(0x0000006D), helpstring("Clear the Action list.\0ue in CSV format\0ol queue by time, action code, and device handle (user defined). Returns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ClearActions(void);
    [propget, id(0x0000006E), helpstring("Pops next action off the action list and makes it the active action. Returns Number of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PopAction([out, retval] long* Value);
  };

  [
    uuid(9A3FFA05-5B82-488C-B08D-FCA2FDB23101),
    version(1.0),
    helpstring("Dispatch interface for Loads Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ILoads: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing all Load names\0he active action. Returns Number of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Set first Load element to be active; returns 0 if none.\0tive action. Returns Number of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets next Load element to be active; returns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Set active load by name.\0 be active; returns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CC), helpstring("Set active load by name.\0 be active; returns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("Sets active load by index into load list.\0ns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Idx([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Sets active load by index into load list.\0ns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Idx([in] long Value);
    [propget, id(0x000000CE), helpstring("Set kW for active Load\0ex into load list.\0ns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kW([out, retval] double* Value);
    [propput, id(0x000000CE), helpstring("Set kW for active Load\0ex into load list.\0ns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kW([in] double Value);
    [propget, id(0x000000CF), helpstring("Set kV rating for active Load. For 2 or more phases set Line-Line kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Set kV rating for active Load. For 2 or more phases set Line-Line kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000D0), helpstring("Set kvar for active Load.\0oad. For 2 or more phases set Line-Line kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000D0), helpstring("Set kvar for active Load.\0oad. For 2 or more phases set Line-Line kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kvar([in] double Value);
    [propget, id(0x000000D1), helpstring("Set Power Factor for Active Load. Specify leading PF as negative.\0kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PF([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Set Power Factor for Active Load. Specify leading PF as negative.\0kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PF([in] double Value);
    [propget, id(0x000000D2), helpstring("Number of Load objects in active circuit.\0leading PF as negative.\0kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000D3), helpstring("Average percent of nominal load in Monte Carlo studies; only if no loadshape defined for this load.")]
    HRESULT _stdcall PctMean([out, retval] double* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall PctMean([in] double Value);
    [propget, id(0x000000D4), helpstring("Percent standard deviation for Monte Carlo load studies; if there is no loadshape assigned to this load.")]
    HRESULT _stdcall PctStdDev([out, retval] double* Value);
    [propput, id(0x000000D4)]
    HRESULT _stdcall PctStdDev([in] double Value);
    [propget, id(0x000000D5), helpstring("Factor for allocating loads by connected xfkva")]
    HRESULT _stdcall AllocationFactor([out, retval] double* Value);
    [propput, id(0x000000D5)]
    HRESULT _stdcall AllocationFactor([in] double Value);
    [propget, id(0x000000D6), helpstring("Factor relates average to peak kw.  Used for allocation with kwh and kwhdays/")]
    HRESULT _stdcall Cfactor([out, retval] double* Value);
    [propput, id(0x000000D6)]
    HRESULT _stdcall Cfactor([in] double Value);
    [propget, id(0x000000D7), helpstring("A code number used to separate loads by class or group. No effect on the solution.")]
    HRESULT _stdcall Class([out, retval] long* Value);
    [propput, id(0x000000D7)]
    HRESULT _stdcall Class([in] long Value);
    [propget, id(0x000000D8), helpstring("Delta loads are connected line-to-line.")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D8)]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000D9), helpstring("Name of a loadshape with both Mult and Qmult, for CVR factors as a function of time.")]
    HRESULT _stdcall CVRcurve([out, retval] BSTR* Value);
    [propput, id(0x000000D9)]
    HRESULT _stdcall CVRcurve([in] BSTR Value);
    [propget, id(0x000000DA), helpstring("Percent reduction in P for percent reduction in V. Must be used with dssLoadModelCVR.")]
    HRESULT _stdcall CVRwatts([out, retval] double* Value);
    [propput, id(0x000000DA)]
    HRESULT _stdcall CVRwatts([in] double Value);
    [propget, id(0x000000DB), helpstring("Percent reduction in Q for percent reduction in V. Must be used with dssLoadModelCVR.")]
    HRESULT _stdcall CVRvars([out, retval] double* Value);
    [propput, id(0x000000DB)]
    HRESULT _stdcall CVRvars([in] double Value);
    [propget, id(0x000000DC), helpstring("Name of the loadshape for a daily load profile.")]
    HRESULT _stdcall daily([out, retval] BSTR* Value);
    [propput, id(0x000000DC)]
    HRESULT _stdcall daily([in] BSTR Value);
    [propget, id(0x000000DD), helpstring("Name of the loadshape for a duty cycle simulation.")]
    HRESULT _stdcall duty([out, retval] BSTR* Value);
    [propput, id(0x000000DD)]
    HRESULT _stdcall duty([in] BSTR Value);
    [propget, id(0x000000DF), helpstring("Base load kva. Also defined kw and kvar or pf input, or load allocation by kwh or xfkva.")]
    HRESULT _stdcall kva([out, retval] double* Value);
    [propput, id(0x000000DF)]
    HRESULT _stdcall kva([in] double Value);
    [propget, id(0x000000E0), helpstring("kwh billed for this period. Can be used with Cfactor for load allocation.")]
    HRESULT _stdcall kwh([out, retval] double* Value);
    [propput, id(0x000000E0)]
    HRESULT _stdcall kwh([in] double Value);
    [propget, id(0x000000E1), helpstring("Length of kwh billing period for average demand calculation. Default 30.")]
    HRESULT _stdcall kwhdays([out, retval] double* Value);
    [propput, id(0x000000E1)]
    HRESULT _stdcall kwhdays([in] double Value);
    [propget, id(0x000000E2), helpstring("The Load Model defines variation of P and Q with voltage.")]
    HRESULT _stdcall Model([out, retval] enum LoadModels* Value);
    [propput, id(0x000000E2)]
    HRESULT _stdcall Model([in] enum LoadModels Value);
    [propget, id(0x000000E3), helpstring("Number of customers in this load, defaults to one.")]
    HRESULT _stdcall NumCust([out, retval] long* Value);
    [propput, id(0x000000E3)]
    HRESULT _stdcall NumCust([in] long Value);
    [propget, id(0x000000E4), helpstring("Neutral resistance for wye-connected loads.")]
    HRESULT _stdcall Rneut([out, retval] double* Value);
    [propput, id(0x000000E4)]
    HRESULT _stdcall Rneut([in] double Value);
    [propget, id(0x000000E5), helpstring("Name of harmonic current spectrrum shape.")]
    HRESULT _stdcall Spectrum([out, retval] BSTR* Value);
    [propput, id(0x000000E5)]
    HRESULT _stdcall Spectrum([in] BSTR Value);
    [propget, id(0x000000E6), helpstring("Maximum per-unit voltage to use the load model. Above this, constant Z applies.")]
    HRESULT _stdcall Vmaxpu([out, retval] double* Value);
    [propput, id(0x000000E6)]
    HRESULT _stdcall Vmaxpu([in] double Value);
    [propget, id(0x000000E7), helpstring("Minimum voltage for unserved energy (UE) evaluation.")]
    HRESULT _stdcall Vminemerg([out, retval] double* Value);
    [propput, id(0x000000E7)]
    HRESULT _stdcall Vminemerg([in] double Value);
    [propget, id(0x000000E8), helpstring("Minimum voltage for energy exceeding normal (EEN) evaluations.")]
    HRESULT _stdcall Vminnorm([out, retval] double* Value);
    [propput, id(0x000000E8)]
    HRESULT _stdcall Vminnorm([in] double Value);
    [propget, id(0x000000E9), helpstring("Minimum voltage to apply the load model. Below this, constant Z is used.")]
    HRESULT _stdcall Vminpu([out, retval] double* Value);
    [propput, id(0x000000E9)]
    HRESULT _stdcall Vminpu([in] double Value);
    [propget, id(0x000000EA), helpstring("Rated service transformer kVA for load allocation, using AllocationFactor. Affects kW, kvar, and pf.")]
    HRESULT _stdcall xfkVA([out, retval] double* Value);
    [propput, id(0x000000EA)]
    HRESULT _stdcall xfkVA([in] double Value);
    [propget, id(0x000000EB), helpstring("Neutral reactance for wye-connected loads.")]
    HRESULT _stdcall Xneut([out, retval] double* Value);
    [propput, id(0x000000EB)]
    HRESULT _stdcall Xneut([in] double Value);
    [propget, id(0x000000EC), helpstring("Name of yearly duration loadshape")]
    HRESULT _stdcall Yearly([out, retval] BSTR* Value);
    [propput, id(0x000000EC)]
    HRESULT _stdcall Yearly([in] BSTR Value);
    [propget, id(0x000000ED), helpstring("Response to load multipliers: Fixed (growth only), Exempt (no LD curve), Variable (all).")]
    HRESULT _stdcall Status([out, retval] enum LoadStatus* Value);
    [propput, id(0x000000ED)]
    HRESULT _stdcall Status([in] enum LoadStatus Value);
    [propget, id(0x000000DE), helpstring("Name of the growthshape curve for yearly load growth factors.")]
    HRESULT _stdcall Growth([out, retval] BSTR* Value);
    [propput, id(0x000000DE)]
    HRESULT _stdcall Growth([in] BSTR Value);
  };

  [
    uuid(C22D4922-6DC2-4283-93AB-4F2138C4B922),
    version(1.0),
    helpstring("Dispatch interface for DSSElement Object\0\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IDSSElement: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Full Name of Active DSS Object (general element or circuit element).\0 Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propget, id(0x000000CA), helpstring("Collection of properties for Active DSS object (general element or circuit element).\0across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Properties([in] VARIANT Indx, [out, retval] IDSSProperty** Value);
    [propget, id(0x000000CB), helpstring("Number of Properties for the active DSS object.\0general element or circuit element).\0across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumProperties([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Variant array of strings containing the names of all properties for the active DSS object.\0 terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllPropertyNames([out, retval] VARIANT* Value);
  };

  [
    uuid(8E73B64C-0D99-4D19-AB90-170DBBD06FA0),
    version(1.0),
    helpstring("Dispatch interface for ActiveClass Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IActiveClass: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings consisting of all element names in the active class.\0 DSS object.\0 terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Sets first element in the active class to be the active DSS object. If object is a CktElement, ActiveCktELment also points to this element. Returns 0 if none.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets next element in active class to be the active DSS object. If object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC)]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CC)]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("Number of elements in this class. Same as Count property.\0ect. If object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumElements([out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Returns name of active class.\0ss. Same as Count property.\0ect. If object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveClassName([out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Number of elements in Active Class. Same as NumElements Property.\0object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(3C171A69-40AB-46AA-B037-9C4EBB9FBFCD),
    version(1.0),
    helpstring("Dispatch interface for Capacitors\0 Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ICapacitors: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Bank kV rating. Use LL for 2 or 3 phases, or actual can rating for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000C9), helpstring("Bank kV rating. Use LL for 2 or 3 phases, or actual can rating for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000CA), helpstring("Total bank KVAR, distributed equally among phases and steps.\0g for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000CA), helpstring("Total bank KVAR, distributed equally among phases and steps.\0g for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kvar([in] double Value);
    [propget, id(0x000000CB), helpstring("Number of steps (default 1) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumSteps([out, retval] long* Value);
    [propput, id(0x000000CB), helpstring("Number of steps (default 1) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumSteps([in] long Value);
    [propget, id(0x000000CC), helpstring("Delta connection or wye?\x01) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CC), helpstring("Delta connection or wye?\x01) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000CD), helpstring("Variant array of strings with all Capacitor names in the circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("Sets the first Capacitor active. Returns 0 if no more.\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CF), helpstring("Sets the next Capacitor active. Returns 0 if no more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000D0), helpstring("Sets the acitve Capacitor by Name.\0urns 0 if no more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Sets the acitve Capacitor by Name.\0urns 0 if no more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Number of Capacitor objects in active circuit.\0 more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(94E9CACF-A548-4DC2-B460-E2642B501387),
    version(1.0),
    helpstring("Dispatch interface for Transformers\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ITransformers: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of windings on this transformer. Allocates memory; set or change this property first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumWindings([out, retval] long* Value);
    [propput, id(0x000000C9), helpstring("Number of windings on this transformer. Allocates memory; set or change this property first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumWindings([in] long Value);
    [propget, id(0x000000CA), helpstring("Name of an XfrmCode that supplies electircal parameters for this Transformer.\0roperty first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall XfmrCode([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Name of an XfrmCode that supplies electircal parameters for this Transformer.\0roperty first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall XfmrCode([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Active Winding Number from 1..NumWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Wdg([out, retval] long* Value);
    [propput, id(0x000000CB), helpstring("Active Winding Number from 1..NumWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Wdg([in] long Value);
    [propget, id(0x000000CC), helpstring("Active Winding resistance in %\0umWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R([out, retval] double* Value);
    [propput, id(0x000000CC), helpstring("Active Winding resistance in %\0umWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R([in] double Value);
    [propget, id(0x000000CD), helpstring("Active Winding tap in per-unit.\0mWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tap([out, retval] double* Value);
    [propput, id(0x000000CD), helpstring("Active Winding tap in per-unit.\0mWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tap([in] double Value);
    [propget, id(0x000000CE), helpstring("Active Winding minimum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MinTap([out, retval] double* Value);
    [propput, id(0x000000CE), helpstring("Active Winding minimum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MinTap([in] double Value);
    [propget, id(0x000000CF), helpstring("Active Winding maximum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTap([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Active Winding maximum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTap([in] double Value);
    [propget, id(0x000000D0), helpstring("Active Winding number of tap steps betwein MinTap and MaxTap.\0reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumTaps([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Active Winding number of tap steps betwein MinTap and MaxTap.\0reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumTaps([in] long Value);
    [propget, id(0x000000D1), helpstring("Active Winding kV rating.  Phase-phase for 2 or 3 phases, actual winding kV for 1 phase transformer.\0g properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Active Winding kV rating.  Phase-phase for 2 or 3 phases, actual winding kV for 1 phase transformer.\0g properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000D2), helpstring("Active Winding kVA rating. On winding 1, this also determines normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kVA([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("Active Winding kVA rating. On winding 1, this also determines normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kVA([in] double Value);
    [propget, id(0x000000D3), helpstring("Active Winding neutral reactance [ohms] for wye connections.\0 normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xneut([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Active Winding neutral reactance [ohms] for wye connections.\0 normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xneut([in] double Value);
    [propget, id(0x000000D4), helpstring("Active Winding neutral resistance [ohms] for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rneut([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Active Winding neutral resistance [ohms] for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rneut([in] double Value);
    [propget, id(0x000000D5), helpstring("Active Winding delta or wye connection?\0 for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D5), helpstring("Active Winding delta or wye connection?\0 for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000D6), helpstring("Percent reactance between windings 1 and 2, on winding 1 kVA base. Use for 2-winding or 3-winding transformers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xhl([out, retval] double* Value);
    [propput, id(0x000000D6), helpstring("Percent reactance between windings 1 and 2, on winding 1 kVA base. Use for 2-winding or 3-winding transformers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xhl([in] double Value);
    [propget, id(0x000000D7), helpstring("Percent reactance between windigns 1 and 3, on winding 1 kVA base.  Use for 3-winding transformers only.\0rmers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xht([out, retval] double* Value);
    [propput, id(0x000000D7), helpstring("Percent reactance between windigns 1 and 3, on winding 1 kVA base.  Use for 3-winding transformers only.\0rmers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xht([in] double Value);
    [propget, id(0x000000D8), helpstring("Percent reactance between windings 2 and 3, on winding _1_ kVA base. Use for 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xlt([out, retval] double* Value);
    [propput, id(0x000000D8), helpstring("Percent reactance between windings 2 and 3, on winding _1_ kVA base. Use for 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xlt([in] double Value);
    [propget, id(0x000000D9), helpstring("Sets a Transformer active by Name.\x02 and 3, on winding _1_ kVA base. Use for 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000D9), helpstring("Sets a Transformer active by Name.\x02 and 3, on winding _1_ kVA base. Use for 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000DA), helpstring("Sets the first Transformer active. Returns 0 if no more.\0_ kVA base. Use for 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000DB), helpstring("Sets the next Transformer active. Returns 0 if no more.\0\0_ kVA base. Use for 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000DC), helpstring("Variant array of strings with all Transformer names in the active circuit.\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000DD)]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(112AB9E6-C112-46BE-A8A3-F72C5FA3A657),
    version(1.0),
    helpstring("Dispatch interface for SwtControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ISwtControls: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings with all SwtControl names in the active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Sets a SwtControl active by Name.\0SwtControl names in the active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Sets a SwtControl active by Name.\0SwtControl names in the active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Sets the first SwtControl active. Returns 0 if no more.\0e active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next SwtControl active. Returns 0 if no more.\0\0e active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Open or Close the switch. No effect if switch is locked.  However, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Action([out, retval] enum ActionCodes* Value);
    [propput, id(0x000000CD), helpstring("Open or Close the switch. No effect if switch is locked.  However, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Action([in] enum ActionCodes Value);
    [propget, id(0x000000CE), helpstring("The lock prevents both manual and automatic switch operation.\0ver, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsLocked([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CE), helpstring("The lock prevents both manual and automatic switch operation.\0ver, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsLocked([in] VARIANT_BOOL Value);
    [propget, id(0x000000CF), helpstring("Time delay [s] betwen arming and opening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Time delay [s] betwen arming and opening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([in] double Value);
    [propget, id(0x000000D0), helpstring("Full name of the switched element.\0ening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedObj([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Full name of the switched element.\0ening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedObj([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Terminal number where the switch is located on the SwitchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedTerm([out, retval] long* Value);
    [propput, id(0x000000D1), helpstring("Terminal number where the switch is located on the SwitchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedTerm([in] long Value);
    [propget, id(0x000000D2)]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(4C132096-4161-4D9B-A701-E6CCCFF1D5AE),
    version(1.0),
    helpstring("Dispatch interface for CapControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ICapControls: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings with all CapControl names.\0witchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Sets a CapControl active by name.\0CapControl names.\0witchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Sets a CapControl active by name.\0CapControl names.\0witchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Sets the first CapControl as active. Return 0 if none.\0chedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Gets the next CapControl in the circut. Returns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Type of automatic controller.\0e circut. Returns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([out, retval] enum CapControlModes* Value);
    [propput, id(0x000000CD), helpstring("Type of automatic controller.\0e circut. Returns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([in] enum CapControlModes Value);
    [propget, id(0x000000CE), helpstring("Name of the Capacitor that is controlled.\0turns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capacitor([out, retval] BSTR* Value);
    [propput, id(0x000000CE), helpstring("Name of the Capacitor that is controlled.\0turns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capacitor([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Full name of the element that PT and CT are connected to.\0\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredObj([out, retval] BSTR* Value);
    [propput, id(0x000000CF), helpstring("Full name of the element that PT and CT are connected to.\0\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredObj([in] BSTR Value);
    [propget, id(0x000000D0), helpstring("Terminal number on the element that PT and CT are connected to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredTerm([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Terminal number on the element that PT and CT are connected to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredTerm([in] long Value);
    [propget, id(0x000000D1), helpstring("Transducer ratio from pirmary current to control current.\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTratio([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Transducer ratio from pirmary current to control current.\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTratio([in] double Value);
    [propget, id(0x000000D2), helpstring("Transducer ratio from primary feeder to control voltage.\0\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("Transducer ratio from primary feeder to control voltage.\0\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([in] double Value);
    [propget, id(0x000000D3), helpstring("Threshold to arm or switch on a step.  See Mode for units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ONSetting([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Threshold to arm or switch on a step.  See Mode for units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ONSetting([in] double Value);
    [propget, id(0x000000D4), helpstring("Threshold to switch off a step. See Mode for units.\0units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall OFFSetting([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Threshold to switch off a step. See Mode for units.\0units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall OFFSetting([in] double Value);
    [propget, id(0x000000D5), helpstring("With VoltOverride, swtich off whenever PT voltage exceeds this level.\0ol may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmax([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("With VoltOverride, swtich off whenever PT voltage exceeds this level.\0ol may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmax([in] double Value);
    [propget, id(0x000000D6), helpstring("With VoltOverride, switch ON whenever PT voltage drops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmin([out, retval] double* Value);
    [propput, id(0x000000D6), helpstring("With VoltOverride, switch ON whenever PT voltage drops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmin([in] double Value);
    [propget, id(0x000000D7), helpstring("Enables Vmin and Vmax to override the control Mode\0ops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UseVoltOverride([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D7), helpstring("Enables Vmin and Vmax to override the control Mode\0ops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UseVoltOverride([in] VARIANT_BOOL Value);
    [propget, id(0x000000D8), helpstring("Time delay [s] to switch on after arming.  Control may reset before actually switching.\0e actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000D8), helpstring("Time delay [s] to switch on after arming.  Control may reset before actually switching.\0e actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([in] double Value);
    [propget, id(0x000000D9), helpstring("Time delay [s] before swithcing off a step. Control may reset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DelayOff([out, retval] double* Value);
    [propput, id(0x000000D9), helpstring("Time delay [s] before swithcing off a step. Control may reset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DelayOff([in] double Value);
    [propget, id(0x000000DA)]
    HRESULT _stdcall DeadTime([out, retval] double* Value);
    [propput, id(0x000000DA)]
    HRESULT _stdcall DeadTime([in] double Value);
    [propget, id(0x000000DB), helpstring("Number of CapControls in Active Circuit\0ep. Control may reset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(3F983AD2-B658-4CE8-B4C1-DE0A9EDD47FD),
    version(1.0),
    helpstring("Dispatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IRegControls: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing all RegControl names\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Sets a RegControl active by name\0ng all RegControl names\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Sets a RegControl active by name\0ng all RegControl names\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Sets the first RegControl active. Returns 0 if none.\0mes\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next RegControl active. Returns 0 if none.\0\0mes\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Name of a remote regulated bus, in lieu of LDC settings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredBus([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Name of a remote regulated bus, in lieu of LDC settings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredBus([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Name of the transformer this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Transformer([out, retval] BSTR* Value);
    [propput, id(0x000000CE), helpstring("Name of the transformer this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Transformer([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Tapped winding number\0r this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapWinding([out, retval] long* Value);
    [propput, id(0x000000CF), helpstring("Tapped winding number\0r this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapWinding([in] long Value);
    [propget, id(0x000000D0), helpstring("Winding number for PT and CT connections\0ntrols\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Winding([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Winding number for PT and CT connections\0ntrols\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Winding([in] long Value);
    [propget, id(0x000000D1), helpstring("CT primary ampere rating (secondary is 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTPrimary([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("CT primary ampere rating (secondary is 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTPrimary([in] double Value);
    [propget, id(0x000000D2), helpstring("PT ratio for voltage control settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("PT ratio for voltage control settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([in] double Value);
    [propget, id(0x000000D3), helpstring("LDC R setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardR([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("LDC R setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardR([in] double Value);
    [propget, id(0x000000D4), helpstring("LDC X setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardX([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("LDC X setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardX([in] double Value);
    [propget, id(0x000000D5), helpstring("Reverse LDC R setting in Volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseR([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Reverse LDC R setting in Volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseR([in] double Value);
    [propget, id(0x000000D6), helpstring("Reverse LDC X setting in volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseX([out, retval] double* Value);
    [propput, id(0x000000D6), helpstring("Reverse LDC X setting in volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseX([in] double Value);
    [propget, id(0x000000D7), helpstring("Regulator can use different settings in the reverse direction.  Usually not applicable to substation transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsReversible([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D7), helpstring("Regulator can use different settings in the reverse direction.  Usually not applicable to substation transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsReversible([in] VARIANT_BOOL Value);
    [propget, id(0x000000D8), helpstring("Time delay is inversely adjsuted, proportinal to the amount of voltage outside the regulating band.\0 transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsInverseTime([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D8), helpstring("Time delay is inversely adjsuted, proportinal to the amount of voltage outside the regulating band.\0 transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsInverseTime([in] VARIANT_BOOL Value);
    [propget, id(0x000000D9), helpstring("Time delay [s] after arming before the first tap change. Control may reset before actually changing taps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000D9), helpstring("Time delay [s] after arming before the first tap change. Control may reset before actually changing taps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([in] double Value);
    [propget, id(0x000000DA), helpstring("Time delay [s] for subsequent tap changes in a set. Control may reset before actually changing taps.\0aps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapDelay([out, retval] double* Value);
    [propput, id(0x000000DA), helpstring("Time delay [s] for subsequent tap changes in a set. Control may reset before actually changing taps.\0aps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapDelay([in] double Value);
    [propget, id(0x000000DB), helpstring("Maximum tap change per iteration in STATIC solution mode. 1 is more realistic, 16 is the default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTapChange([out, retval] long* Value);
    [propput, id(0x000000DB), helpstring("Maximum tap change per iteration in STATIC solution mode. 1 is more realistic, 16 is the default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTapChange([in] long Value);
    [propget, id(0x000000DC), helpstring("First house voltage limit on PT secondary base.  Setting to 0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageLimit([out, retval] double* Value);
    [propput, id(0x000000DC), helpstring("First house voltage limit on PT secondary base.  Setting to 0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageLimit([in] double Value);
    [propget, id(0x000000DD), helpstring("Regulation bandwidth in forward direciton, centered on Vreg\0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardBand([out, retval] double* Value);
    [propput, id(0x000000DD), helpstring("Regulation bandwidth in forward direciton, centered on Vreg\0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardBand([in] double Value);
    [propget, id(0x000000DE), helpstring("Target voltage in the forward direction, on PT secondary base.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardVreg([out, retval] double* Value);
    [propput, id(0x000000DE), helpstring("Target voltage in the forward direction, on PT secondary base.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardVreg([in] double Value);
    [propget, id(0x000000DF), helpstring("Bandwidth in reverse direction, centered on reverse Vreg.\0ase.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseBand([out, retval] double* Value);
    [propput, id(0x000000DF), helpstring("Bandwidth in reverse direction, centered on reverse Vreg.\0ase.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseBand([in] double Value);
    [propget, id(0x000000E0), helpstring("Target voltage in the revese direction, on PT secondary base.\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseVreg([out, retval] double* Value);
    [propput, id(0x000000E0), helpstring("Target voltage in the revese direction, on PT secondary base.\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseVreg([in] double Value);
    [propget, id(0x000000E1), helpstring("Number of RegControl objects in Active Circuit\0econdary base.\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(D35F8A94-9DED-443C-A7B9-62E9C3D5EB9F),
    version(1.0),
    helpstring("Dispatch interface for Plot Object\0\0e\0s\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IPlot: IDispatch
  {
    [id(0x000000C9), helpstring("Make a New DSS Graph Object\0both manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NewGraph([out, retval] long* Value);
    [id(0x000000CA), helpstring("Add a new line to active graph.\0 manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NewLine([in] double X1, [in] double Y1, [in] double X2, [in] double Y2, [in] BSTR Name);
    [id(0x000000CB), helpstring("Add a new curve of x and y arrays to graph\0 automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NewCurve([in] VARIANT Xarray, [in] VARIANT Yarray, [in] BSTR Name);
    [id(0x000000CC), helpstring("Add a new text string to plot.\0ys to graph\0 automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NewText([in] double X1, [in] double Y1, [in] BSTR S);
    [id(0x000000CD), helpstring("Add a new circle to the plot\0.\0ys to graph\0 automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NewCircle([in] double Xc, [in] double Yc, [in] double Radius);
    [id(0x000000CE), helpstring("Put a marker at specified (x,y). Marker code range is 0..47.\0on\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NewMarker([in] double x, [in] double y, [in] unsigned char MarkerCode, [in] unsigned char MarkerSize);
    [propput, id(0x000000CF), helpstring("X Axis Label\0at specified (x,y). Marker code range is 0..47.\0on\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall XLabel([in] BSTR Param1);
    [propput, id(0x000000D0), helpstring("Y Axis label\0at specified (x,y). Marker code range is 0..47.\0on\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall YLabel([in] BSTR Param1);
    [propput, id(0x000000D1), helpstring("Caption on Graph Window\0d (x,y). Marker code range is 0..47.\0on\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall WindowCaption([in] BSTR Param1);
    [propput, id(0x000000D2), helpstring("Caption for the plot (chart)\0y). Marker code range is 0..47.\0on\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PlotCaption([in] BSTR Param1);
    [propput, id(0x000000D3), helpstring("Set Line Width (thickness)\0)\0y). Marker code range is 0..47.\0on\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LineWidth([in] long Param1);
    [propput, id(0x000000D4), helpstring("Set data or line color (RGB value)\0rker code range is 0..47.\0on\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DataColor([in] long Param1);
    [propput, id(0x000000D5), helpstring("Set penstyle: 0=Solid(default), 1=Dash, 2=dot, 3=Dashdot,4=Dashdotdot, 5=Clear\0ction.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PenStyle([in] long Param1);
    [id(0x000000D6), helpstring("Set Font Style: Indicate styles by True/False argument\0t,4=Dashdotdot, 5=Clear\0ction.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetFontStyle([in] VARIANT_BOOL Bold, [in] VARIANT_BOOL Italic, [in] VARIANT_BOOL Underline, [in] VARIANT_BOOL Strikeout);
    [propput, id(0x000000D7), helpstring("Mark the ends (nodes) of lines added with NewLine method. Default is FALSE.\0ar\0ction.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MarkNodes([in] VARIANT_BOOL Param1);
    [propput, id(0x000000D8), helpstring("Code for node marker symbol. Default = 16. Range: 0..47\0. Default is FALSE.\0ar\0ction.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NodeMarkerCode([in] long Param1);
    [propput, id(0x000000D9), helpstring("Mark the center of lines added with NewLine method. Default is FALSE.\0ALSE.\0ar\0ction.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MarkCenter([in] VARIANT_BOOL Param1);
    [propput, id(0x000000DA), helpstring("Code in range of 0..47 indicating which marker to use for marking the line center.\0n.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CenterMarkerCode([in] long Param1);
    [propput, id(0x000000DB), helpstring("Integer representing the size of the Node marker for lines added with NewLine method. Default = 1.\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NodeMarkerWidth([in] long Param1);
    [propput, id(0x000000DC), helpstring("Mark curves added by the NewCurve method. Default = FALSE.\0added with NewLine method. Default = 1.\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MarkCurves([in] VARIANT_BOOL Param1);
    [propput, id(0x000000DD), helpstring("Code in range of 0..47 for symbol to place on a curve added with NewCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CurveMarkerCode([in] long Param1);
    [id(0x000000DE), helpstring("Move to point (set drawing cursor at this point)\0urve added with NewCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MoveToXY([in] double x, [in] double y);
    [id(0x000000DF), helpstring("Draw a line from the previous drawing cursor location to this one.\0wCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DrawToXY([in] double x, [in] double y);
    [id(0x000000E0), helpstring("Draw a rectangle at the specified corner coordinates.\0to this one.\0wCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DrawRectangle([in] double XLowerLeft, [in] double YLowerLeft, [in] double XUpperRight, [in] double YUpperRight);
    [id(0x000000E1), helpstring("Show the graph/plot with updated changes.\0oordinates.\0to this one.\0wCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Show(void);
    [id(0x000000E2), helpstring("Set the extent range for the graph.\0nges.\0oordinates.\0to this one.\0wCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetRange([in] double Xlow, [in] double Xhigh, [in] double Ylow, [in] double Yhigh);
    [id(0x000000E3), helpstring("Get the present extent range of the graph.\0ordinates.\0to this one.\0wCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GetRange([in, out] double* Xlow, [in, out] double* Xhigh, [in, out] double* Ylow, [in, out] double* Yhigh);
    [propput, id(0x000000E4), helpstring("Set Text size; Default = 1;\0 of the graph.\0ordinates.\0to this one.\0wCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TextSize([in] long Param1);
    [propput, id(0x000000E5), helpstring("Color code for text; Default = Black;\0aph.\0ordinates.\0to this one.\0wCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TextColor([in] long Param1);
    [propput, id(0x000000E6), helpstring("Default = 1 = left justify; 2= center; 3 = right justify\0this one.\0wCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TextAlign([in] long Param1);
    [id(0x000000E7), helpstring("Add a new text label; returns an index for later reference.\0s one.\0wCurve method.  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AddLabel([in] double x, [in] double y, [in] BSTR Txt, [out, retval] long* Value);
    [id(0x000000E8), helpstring("Locks in text label added by AddLabel method. Index is return value of Addlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LockInLabel([in] long TxtIndex);
    [id(0x000000E9), helpstring("Set label referenced by index to Bold.\0ethod. Index is return value of Addlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetLabelBold([in] long LblIndex);
    [id(0x000000EA), helpstring("Set label referenced by Index to Left Justify and transparent\0value of Addlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetLabelLeft([in] long LblIndex);
    [id(0x000000EB), helpstring("Add centered text 15 or less characters.\0tify and transparent\0value of Addlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AddCentered15([in] double x, [in] double y, [in] BSTR Txt);
    [propput, id(0x000000EC), helpstring("Set % rim on the plot using AutoRange feature.\0nd transparent\0value of Addlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall pctRim([in] double Param1);
    [propput, id(0x000000ED), helpstring("True/False;  Keep Aspect Ratio on plot.\0ature.\0nd transparent\0value of Addlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall KeepAspect([in] VARIANT_BOOL Param1);
    [id(0x000000EE), helpstring("Set the plot to have no scales displayed.\0ure.\0nd transparent\0value of Addlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetForNoScales(void);
    [id(0x000000EF), helpstring("Enable user to click on circuit diagram, for example.\0sparent\0value of Addlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetForClickOnDiagram(void);
    [id(0x000000F0), helpstring("Put a specified marker at location on graph. Marker code range is 0..47;\0dlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MarkAtXY([in] double x, [in] double y, [in] unsigned char MarkerCode, [in] unsigned char MarkerSize);
    [id(0x000000F1), helpstring("Get present plot window parameters.\0n graph. Marker code range is 0..47;\0dlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GetWindowParms([in, out] long* Width, [in, out] long* LRim, [in, out] long* RRim, [in, out] long* Height, [in, out] long* TRim, [in, out] long* Brim);
    [id(0x000000F2), helpstring("Get various properties of the active graph.\0 Marker code range is 0..47;\0dlabel.\0  Default=5 (x).\0\0r a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GetGraphProperties([in, out] double* Xmin, [in, out] double* Xmax, [in, out] double* Ymin, [in, out] double* Ymax, [in, out] long* ChartColor, [in, out] long* WindowColor, [in, out] VARIANT_BOOL* Isometric, [in, out] long* Gridstyle);
    [id(0x000000F3), helpstring("Opposite of GetGraphProperties; Do GetGraphProperties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall SetGraphProperties([in] double Xmin, [in] double Xmax, [in] double Ymin, [in] double Ymax, [in] long ChartColor, [in] long WindowColor, [in] VARIANT_BOOL Isometric, [in] long Gridstyle);
  };

  [
    uuid(03FADB98-4F30-416E-ACD2-9BD987A0CBC3),
    version(1.0),
    helpstring("Dispatch interface for Topology Object\0\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ITopology: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of loops\0raphProperties; Do GetGraphProperties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall NumLoops([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Number of isolated branches (PD elements and capacitors).")]
    HRESULT _stdcall NumIsolatedBranches([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Variant array of all looped element names, by pairs.")]
    HRESULT _stdcall AllLoopedPairs([out, retval] VARIANT* Value);
    [propget, id(0x000000CC), helpstring("Variant array of all isolated branch names.")]
    HRESULT _stdcall AllIsolatedBranches([out, retval] VARIANT* Value);
    [propget, id(0x000000CD), helpstring("Number of isolated loads")]
    HRESULT _stdcall NumIsolatedLoads([out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Variant array of all isolated load names.")]
    HRESULT _stdcall AllIsolatedLoads([out, retval] VARIANT* Value);
    [propget, id(0x000000CF), helpstring("Name of the active branch.")]
    HRESULT _stdcall BranchName([out, retval] BSTR* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall BranchName([in] BSTR Value);
    [propget, id(0x000000D0), helpstring("Sets the first branch active, returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000D1), helpstring("Sets the next branch active, returns 0 if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000D2), helpstring("Returns index of the active branch")]
    HRESULT _stdcall ActiveBranch([out, retval] long* Value);
    [propget, id(0x000000D3), helpstring("Move forward in the tree, return index of new active branch or 0 if no more")]
    HRESULT _stdcall ForwardBranch([out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("MOve back toward the source, return index of new active branch, or 0 if no more.")]
    HRESULT _stdcall BackwardBranch([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("Move to looped branch, return index or 0 if none.")]
    HRESULT _stdcall LoopedBranch([out, retval] long* Value);
    [propget, id(0x000000D6), helpstring("Move to directly parallel branch, return index or 0 if none.")]
    HRESULT _stdcall ParallelBranch([out, retval] long* Value);
    [propget, id(0x000000D7), helpstring("First load at the active branch, return index or 0 if none.")]
    HRESULT _stdcall FirstLoad([out, retval] long* Value);
    [propget, id(0x000000D9), helpstring("Next load at the active branch, return index or 0 if no more.")]
    HRESULT _stdcall NextLoad([out, retval] long* Value);
    [propget, id(0x000000D8), helpstring("Topological depth of the active branch")]
    HRESULT _stdcall ActiveLevel([out, retval] long* Value);
    [propget, id(0x000000DA)]
    HRESULT _stdcall BusName([out, retval] BSTR* Value);
    [propput, id(0x000000DA), helpstring("Set the active branch to one containing this bus, return index or 0 if not found")]
    HRESULT _stdcall BusName([in] BSTR Value);
  };

  [
    uuid(DD7B80E9-5EFB-4E79-96CA-9C88F5A8A11C),
    version(1.0),
    helpstring("Dispatch interface for DSS_Executive Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IDSS_Executive: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of DSS Executive Commands\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall NumCommands([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Number of DSS Executive Options\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall NumOptions([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Get i-th command\0cutive Options\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall Command([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CC), helpstring("Get i-th option\0\0cutive Options\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall Option([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CD), helpstring("Get help string for i-th command\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall CommandHelp([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CE), helpstring("Get help string for i-th option\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall OptionHelp([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Get present value of i-th option\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall OptionValue([in] long i, [out, retval] BSTR* Value);
  };

  [
    uuid(3F5A5530-4E67-44BF-AE6D-561584C6BF47),
    helpstring("Dispatch interface for DSSEvents Object"),
    dual,
    oleautomation
  ]
  interface IDSSEvents: IDispatch
  {
  };

  [
    uuid(E7444ECD-B491-4D8E-A1E3-E5804BD571E2),
    helpstring("Dispatch interface for Sensors Object"),
    dual,
    oleautomation
  ]
  interface ISensors: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Name of the active sensor.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000C9), helpstring("Set the active Sensor by name.")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CA), helpstring("Number of Sensors in Active Circuit.")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets the first sensor active. Returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next Sensor active. Returns 0 if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Variant array of Sensor names.")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("True if measured voltages are line-line. Currents are always line currents.")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000CF), helpstring("True if voltage measurements are 1-3, 3-2, 2-1.")]
    HRESULT _stdcall ReverseDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall ReverseDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000D0), helpstring("Assumed percent error in the Sensor measurement. Default is 1.")]
    HRESULT _stdcall PctError([out, retval] double* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall PctError([in] double Value);
    [propget, id(0x000000D1), helpstring("Weighting factor for this Sensor measurement with respect to other Sensors. Default is 1.")]
    HRESULT _stdcall Weight([out, retval] double* Value);
    [propput, id(0x000000D1)]
    HRESULT _stdcall Weight([in] double Value);
    [propget, id(0x000000D2), helpstring("Full Name of the measured element")]
    HRESULT _stdcall MeteredElement([out, retval] BSTR* Value);
    [propput, id(0x000000D2)]
    HRESULT _stdcall MeteredElement([in] BSTR Value);
    [propget, id(0x000000D3), helpstring("Number of the measured terminal in the measured element.")]
    HRESULT _stdcall MeteredTerminal([out, retval] long* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall MeteredTerminal([in] long Value);
    [id(0x000000D4), helpstring("Clear the active Sensor.")]
    HRESULT _stdcall Reset(void);
    [id(0x000000D5), helpstring("Clear all Sensors in the Active Circuit.")]
    HRESULT _stdcall ResetAll(void);
    [propget, id(0x000000D6), helpstring("Voltage base for the sensor measurements. LL for 2 and 3-phase sensors, LN for 1-phase sensors.")]
    HRESULT _stdcall kVbase([out, retval] double* Value);
    [propput, id(0x000000D6)]
    HRESULT _stdcall kVbase([in] double Value);
    [propget, id(0x000000D7), helpstring("Array of doubles for the line current measurements; don't use with kWS and kVARS.")]
    HRESULT _stdcall Currents([out, retval] VARIANT* Value);
    [propput, id(0x000000D7)]
    HRESULT _stdcall Currents([in] VARIANT Value);
    [propget, id(0x000000D8), helpstring("Array of doubles for the LL or LN (depending on Delta connection) voltage measurements.")]
    HRESULT _stdcall kVS([out, retval] VARIANT* Value);
    [propput, id(0x000000D8)]
    HRESULT _stdcall kVS([in] VARIANT Value);
    [propget, id(0x000000D9), helpstring("Array of doubles for Q measurements. Overwrites Currents with a new estimate using kWS.")]
    HRESULT _stdcall kVARS([out, retval] VARIANT* Value);
    [propput, id(0x000000D9)]
    HRESULT _stdcall kVARS([in] VARIANT Value);
    [propget, id(0x000000DA), helpstring("Array of doubles for P measurements. Overwrites Currents with a new estimate using kVARS.")]
    HRESULT _stdcall kWS([out, retval] VARIANT* Value);
    [propput, id(0x000000DA)]
    HRESULT _stdcall kWS([in] VARIANT Value);
  };

  [
    uuid(AE501F77-F7F0-4201-A9AD-6AB385262203),
    helpstring("Events interface for DSSEvents Object")
  ]
  dispinterface IDSSEventsEvents
  {
    properties:
    methods:
    [id(0x000000C9), helpstring("Notification to initialize the control model.")]
    HRESULT InitControls(void);
    [id(0x000000CA), helpstring("Notification that a time step solution is complete, and the control should update itself.")]
    HRESULT StepControls(void);
    [id(0x000000CB), helpstring("Notification that a system solution has been performed, and controls should check and possibly create new events.")]
    HRESULT CheckControls(void);
  };

  [
    uuid(6E20BC4C-67C0-4AD3-9E12-BF90C478A1CC),
    version(1.0),
    helpstring("Text Object\0erface for Text Object\0\0e\0;\0p\x12\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Text
  {
    [default] interface IText;
  };

  [
    uuid(F8410F14-7E85-44A9-B42F-F900DF5F596E),
    version(1.0),
    helpstring("DSSProperty Object\0for DSSProperty Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSSProperty
  {
    [default] interface IDSSProperty;
  };

  [
    uuid(BC5F55A3-7A0F-4923-B218-098A91F482D8),
    version(1.0),
    helpstring("CktElementObject\0e for CktElement Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass CktElement
  {
    [default] interface ICktElement;
  };

  [
    uuid(0038D0EB-28ED-42B0-A247-E212E05ADF4B),
    version(1.0),
    helpstring("Error Object\0rface for Errror Object\0ect\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Error
  {
    [default] interface IError;
  };

  [
    uuid(B5B695B1-A1F5-444F-ABC5-836B7EF1DF0D),
    version(1.0),
    helpstring("Circuit Object\0ace for Circuit Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Circuit
  {
    [default] interface ICircuit;
  };

  [
    uuid(A14C32E4-846B-444D-9070-F7A31E9F5FF9),
    version(1.0),
    helpstring("Bus Object\0terface for Bus Object\0ect\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Bus
  {
    [default] interface IBus;
  };

  [
    uuid(6FE9D1B8-C064-4877-94C0-F13882ADBDB6),
    version(1.0),
    helpstring("DSS Main Object\0ce for DSSMain Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSS
  {
    [default] interface IDSS;
  };

  [
    uuid(F799E1DE-E7BF-4F86-BCED-6DD01FD00419),
    version(1.0),
    helpstring("Solution Object\0ce for Solution Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Solution
  {
    [default] interface ISolution;
  };

  [
    uuid(7FF93D6F-4258-40CB-9558-0792422309F3),
    version(1.0),
    helpstring("Monitors Object\0ce for Monitors Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Monitors
  {
    [default] interface IMonitors;
  };

  [
    uuid(F869D5BB-A023-48AB-A459-01444585B7C1),
    version(1.0),
    helpstring("Meters Object\0face for Meters Object\0t\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Meters
  {
    [default] interface IMeters;
  };

  [
    uuid(65F232C9-7D95-4E45-B9FA-40F518CFBB64),
    version(1.0),
    helpstring("Generators Object\0 for Generators Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Generators
  {
    [default] interface IGenerators;
  };

  [
    uuid(4CB900D9-DD2F-41AF-9E48-B999E0AED0A7),
    version(1.0),
    helpstring("DSSProgress Object\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSSProgress
  {
    [default] interface IDSSProgress;
  };

  [
    uuid(9D910AA4-0CB3-4907-AEEF-8DD79A58C0AD),
    version(1.0),
    helpstring("Settings Object\0ce for Settings Object\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Settings
  {
    [default] interface ISettings;
  };

  [
    uuid(A1352870-9D53-4E48-B83A-6DB0C8FED65B),
    version(1.0),
    helpstring("Lines Object\0rface for Lines Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Lines
  {
    [default] interface ILines;
  };

  [
    uuid(19DD7174-7FEE-4E59-97ED-C54F16EDC3F0),
    version(1.0),
    helpstring("CtrlQueue\0for CtrlQueue Object\0ject\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass CtrlQueue
  {
    [default] interface ICtrlQueue;
  };

  [
    uuid(1302A34B-A554-4C32-BCED-4AF0A94FF114),
    version(1.0),
    helpstring("Loads Object\0rface for Loads Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Loads
  {
    [default] interface ILoads;
  };

  [
    uuid(09D4B4AB-DF58-4F8F-A3F0-72F32830B337),
    version(1.0),
    helpstring("DSSElement Object\0 for DSSElement Object\0\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSSElement
  {
    [default] interface IDSSElement;
  };

  [
    uuid(2A02BB33-50A4-4C87-86E0-59EF7738F86C),
    version(1.0),
    helpstring("ActiveClass Object\0for ActiveClass Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass ActiveClass
  {
    [default] interface IActiveClass;
  };

  [
    uuid(F733F571-4CEC-45CC-922D-16C2BEEBA5BC),
    version(1.0),
    helpstring("\0\x01spatch interface for Capacitors\0 Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Capacitors
  {
    [default] interface ICapacitors;
  };

  [
    uuid(3A3E2154-1249-4DBB-AEDC-C4C14300D332),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Transformers
  {
    [default] interface ITransformers;
  };

  [
    uuid(7D8F53AE-0D61-4B87-9BEE-12D54052F689),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass SwtControls
  {
    [default] interface ISwtControls;
  };

  [
    uuid(7D95304E-B0A8-4531-8D1B-F438287EEA6E),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass CapControls
  {
    [default] interface ICapControls;
  };

  [
    uuid(D3DBDE53-6397-4C36-8C87-9BEA061FBC78),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass RegControls
  {
    [default] interface IRegControls;
  };

  [
    uuid(749A9035-EC8A-45F5-8BC2-B253EBBB78ED),
    version(1.0),
    helpstring("Plot Object\0erface for Plot Object\0\0e\0s\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Plot
  {
    [default] interface IPlot;
  };

  [
    uuid(5B1B5AB3-0595-4E46-B64B-CF8877ED0857),
    version(1.0),
    helpstring("Topology Object\0ce for Topology Object\0\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Topology
  {
    [default] interface ITopology;
  };

  [
    uuid(D00898D0-6CC7-4A3B-BF89-DED9593579E7),
    version(1.0),
    helpstring("DSS_Executive Object\0r DSS_Executive Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSS_Executive
  {
    [default] interface IDSS_Executive;
  };

  [
    uuid(B734843A-08E4-42D3-9E24-C0D5F7BF6487),
    helpstring("DSSEvents Object")
  ]
  coclass DSSEvents
  {
    [default] interface IDSSEvents;
    [default, source] dispinterface IDSSEventsEvents;
  };

  [
    uuid(FC54E9AA-1C6A-4CF8-837D-82B257D98E5A),
    helpstring("Sensors Object")
  ]
  coclass Sensors
  {
    [default] interface ISensors;
  };

};
