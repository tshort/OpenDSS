// ************************************************************************ //
// WARNING
// -------
// This file is generated by the Type Library importer or Type Libary Editor.
// Barring syntax errors, the Editor will parse modifications made to the file.
// However, when applying changes via the Editor this file will be regenerated
// and comments or formatting changes will be lost.
// ************************************************************************ //
// File generated on 5/3/2016 7:26:31 AM (- $Rev: 12980 $, 70886667).

[
  uuid(8BFDE413-245A-4514-B151-B16DCC243796),
  version(1.0),
  helpstring("OpenDSS Engine")

]
library OpenDSSengine
{

  importlib("stdole2.tlb");
  importlib("stdole32.tlb");

  interface IText;
  coclass Text;
  interface IDSSProperty;
  coclass DSSProperty;
  interface ICktElement;
  coclass CktElement;
  interface IError;
  coclass Error;
  interface ICircuit;
  coclass Circuit;
  interface IBus;
  coclass Bus;
  interface IDSS;
  coclass DSS;
  interface ISolution;
  coclass Solution;
  interface IMonitors;
  coclass Monitors;
  interface IMeters;
  coclass Meters;
  interface IGenerators;
  coclass Generators;
  interface IDSSProgress;
  coclass DSSProgress;
  interface ISettings;
  coclass Settings;
  interface ILines;
  coclass Lines;
  interface ICtrlQueue;
  coclass CtrlQueue;
  interface ILoads;
  coclass Loads;
  interface IDSSElement;
  coclass DSSElement;
  interface IActiveClass;
  coclass ActiveClass;
  interface ICapacitors;
  coclass Capacitors;
  interface ITransformers;
  interface ISwtControls;
  interface ICapControls;
  interface IRegControls;
  coclass Transformers;
  coclass SwtControls;
  coclass CapControls;
  coclass RegControls;
  interface ITopology;
  coclass Topology;
  interface IDSS_Executive;
  coclass DSS_Executive;
  interface IDSSEvents;
  dispinterface IDSSEventsEvents;
  coclass DSSEvents;
  interface ISensors;
  coclass Sensors;
  interface IXYCurves;
  coclass XYCurves;
  interface IPDElements;
  coclass PDElements;
  interface IReclosers;
  coclass Reclosers;
  interface IRelays;
  coclass Relays;
  interface ICmathLib;
  coclass CmathLib;
  interface IParser;
  coclass Parser;
  interface ILoadShapes;
  coclass LoadShapes;
  interface IFuses;
  coclass Fuses;
  interface IISources;
  coclass ISources;
  interface IDSSimComs;
  coclass DSSimComs;
  interface IPVSystems;
  coclass PVSystems;
  interface IVsources;
  coclass Vsources;


  [
    uuid(F694AF7D-DE1E-4CC2-8944-7D574FA06E3B),
    version(1.0),
    helpstring("Modes for Monitors\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum MonitorModes
  {
    [helpstring("Monitor records Voltage and Current at the terminal (Default)")]
    dssVI = 0,
    [helpstring("Monitor records kW, kvar or kVA, angle values, etc. at the terminal to which it is connected.")]
    dssPower = 1,
    [helpstring("Reports the monitored quantities as sequence quantities")]
    dssSequence = 16,
    [helpstring("Reports the monitored quantities in Magnitude Only")]
    dssMagnitude = 32,
    [helpstring("Reports the Positive Seq only or avg of all phases")]
    dssPosOnly = 64,
    [helpstring("For monitoring Regulator and Transformer taps")]
    dssTaps = 2,
    [helpstring("For monitoring State Variables (for PC Elements only)")]
    dssStates = 3
  };

  [
    uuid(421FFC54-1D6B-4900-B598-9E3E7E10FDD1),
    version(1.0),
    helpstring("\0\0des for Monitors\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum SolveModes
  {
    [helpstring("Solve a single snapshot power flow\0ses\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssSnapShot = 0,
    [helpstring("Solve following Duty Cycle load shapes\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssDutyCycle = 6,
    [helpstring("Solve direct (forced admittance model)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssDirect = 7,
    [helpstring("Solve following Daily load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssDaily = 1,
    [helpstring("Monte Carlo Mode 1\0ly load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonte1 = 3,
    [helpstring("Monte Carlo Mode 2\0ly load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonte2 = 10,
    [helpstring("Monte Carlo Mode 3\0ly load shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonte3 = 11,
    [helpstring("Fault study at all buses\0d shapes\0del)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssFaultStudy = 9,
    [helpstring("Solve following Yearly load shapes\0el)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssYearly = 2,
    [helpstring("Monte carlo Fault Study\0oad shapes\0el)\0fault)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMonteFault = 8,
    [helpstring("Solves for Peak Day using Daily load curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPeakDay = 5,
    [helpstring("Load-duration Mode 1\0sing Daily load curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssLD1 = 4,
    [helpstring("Load-Duration Mode 2\0sing Daily load curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssLD2 = 12,
    [helpstring("Auto add generators or capacitors\0ad curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAutoAdd = 13,
    dssHarmonic = 15,
    dssDynamic = 14
  };

  [
    uuid(21B577B3-3F77-49B2-8F4D-A21BACDF6964),
    version(1.0),
    helpstring("\0\0des for Monitors\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum Options
  {
    [helpstring("Power Flow load model option\0tors\0ad curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPowerFlow = 1,
    [helpstring("Admittance load model option\0tors\0ad curve\0t)\0ress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAdmittance = 2,
    [helpstring("Solution algorithm option - Normal solution mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssNormalSolve = 0,
    [helpstring("Solution algorithm option - Newton solution\0mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssNewtonSolve = 1,
    [helpstring("Control Mode option - Static\0ewton solution\0mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssStatic = 0,
    [helpstring("Control Mode Option - Event driven solution mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssEvent = 1,
    [helpstring("Control mode option - Time driven mode\0tion mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssTime = 2,
    [helpstring("Circuit model is multiphase (default)\0\0tion mode\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssMultiphase = 0,
    [helpstring("Circuit model is positive sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssPositiveSeq = 1,
    [helpstring("Random mode = Gaussian\0ve sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssGaussian = 1,
    [helpstring("Random mode = Uniform\0\0ve sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssUniform = 2,
    [helpstring("Random Mode = Log normal\0 sequence model only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssLogNormal = 3,
    [helpstring("Add generators in AutoAdd mode (AddType)\0only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAddGen = 1,
    [helpstring("Add capacitors in AutoAdd mode (Addtype)\0only\0de\0s set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssAddCap = 2,
    [helpstring("Control Mode OFF = -1")]
    dssControlOFF = -1
  };

  [
    uuid(6DB3AE70-08E2-45D4-8E83-412C246F4C17),
    version(1.0),
    helpstring("\0\x01o\0d\0e\0C\0e\0n\0t\0r\0a\0l\0 \0E\0x\0a\0m\0p\0l\0e\0s\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum CapControlModes
  {
    [helpstring("voltage control, ON and OFF settings on the PT secondary base\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlVoltage = 1,
    [helpstring("kVAR control, ON and OFF settings on PT / CT base\0ondary base\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlKVAR = 2,
    [helpstring("Current control, ON and OFF settings on CT secondary\0ary base\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlCurrent = 0,
    [helpstring("ON and OFF settings are power factor, negative for leading\0se\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlPF = 4,
    [helpstring("Time control, ON and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssCapControlTime = 3
  };

  [
    uuid(CF246BDE-E2C7-4F1E-9227-A95F8F65F39F),
    version(1.0),
    helpstring("\0\x01o\0d\0e\0C\0e\0n\0t\0r\0a\0l\0 \0E\0x\0a\0m\0p\0l\0e\0s\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  enum ActionCodes
  {
    [helpstring("No action\0ol, ON and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionNone = 0,
    [helpstring("Open a switch\0ON and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionOpen = 1,
    [helpstring("Close a switch\0N and OFF settings are seconds from midnight\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionClose = 2,
    [helpstring("Reset to the shelf state (unlocked, closed for a switch)\0ht\0e\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionReset = 3,
    [helpstring("Lock a switch, prventing both manual and automatic operation\0\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionLock = 4,
    [helpstring("Unlock a switch, permitting both manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionUnlock = 5,
    [helpstring("Move a regulator tap up\0ing both manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionTapUp = 6,
    [helpstring("Move a regulator tap down\0g both manual and automatic operation\0sables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    dssActionTapDown = 7
  };

  [
    uuid(A6526195-0103-45C1-B338-B9875F0B0A96)
  ]
  enum LoadStatus
  {
    dssLoadVariable = 0,
    dssLoadFixed = 1,
    dssLoadExempt = 2
  };

  [
    uuid(83BCFDCC-1FAF-4343-9930-2B6D02F6417D)
  ]
  enum LoadModels
  {
    dssLoadConstPQ = 1,
    dssLoadConstZ = 2,
    dssLoadMotor = 3,
    dssLoadCVR = 4,
    dssLoadConstI = 5,
    dssLoadConstPFixedQ = 6,
    dssLoadConstPFixedX = 7,
    dssLoadZIPV = 8
  };

  [
    uuid(9422E077-D357-4C87-BA49-C193788E755F)
  ]
  enum LineUnits
  {
    [helpstring("No line length unit.")]
    dssLineUnitsNone = 0,
    [helpstring("Line length units in miles.")]
    dssLineUnitsMiles = 1,
    [helpstring("Line length units are in thousand feet.")]
    dssLineUnitskFt = 2,
    [helpstring("Line length units are km.")]
    dssLineUnitskm = 3,
    [helpstring("Line length units are meters.")]
    dssLineUnitsmeter = 4,
    [helpstring("Line units in feet.")]
    dssLineUnitsft = 5,
    [helpstring("Line length units are inches.")]
    dssLineUnitsinch = 6,
    [helpstring("Line units are cm.")]
    dssLineUnitscm = 7,
    [helpstring("Line length units are mm.")]
    dssLineUnitsmm = 8,
    [helpstring("Maximum number of line units constants.")]
    dssLineUnitsMaxnum = 9
  };

  [
    uuid(0513A8DC-2C0D-4648-8BD7-2130B82C05FA),
    version(1.0),
    helpstring("Dispatch interface for Text Object\0\0e\0;\0p\x12\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IText: IDispatch
  {
    [propget, id(0x00000001), helpstring("Input command string for the DSS.\0ve Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Command([out, retval] BSTR* Command);
    [propput, id(0x00000001), helpstring("Input command string for the DSS.\0ve Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Command([in] BSTR Command);
    [propget, id(0x00000002), helpstring("Result string for the last command.\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Result([out, retval] BSTR* Result);
  };

  [
    uuid(1298D126-0750-4B2A-8462-62EFE7310DF2),
    version(1.0),
    helpstring("Dispatch interface for DSSProperty Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IDSSProperty: IDispatch
  {
    [propget, id(0x00000001), helpstring("Name of Property\0 the last command.\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Name);
    [propget, id(0x00000003), helpstring("Description of the property.\0mmand.\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Description([out, retval] BSTR* Description);
    [propget, id(0x00000002)]
    HRESULT _stdcall Val([out, retval] BSTR* Value);
    [propput, id(0x00000002)]
    HRESULT _stdcall Val([in] BSTR Value);
  };

  [
    uuid(F20E8327-5B60-478E-8DBD-5EFC75EB929B),
    version(1.0),
    helpstring("Dispatch interface for CktElement Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface ICktElement: IDispatch
  {
    [propget, id(0x00000001), helpstring("Full Name of Active Circuit Element\0 Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propget, id(0x00000002), helpstring("Number of Terminals this Circuit Element\0ct\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumTerminals([out, retval] long* Value);
    [propget, id(0x00000003), helpstring("Number of Conductors per Terminal\0lement\0ct\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumConductors([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Number of Phases\0ors per Terminal\0lement\0ct\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumPhases([out, retval] long* Value);
    [propget, id(0x00000005), helpstring("Variant array of strings. Get  Bus definitions to which each terminal is connected. 0-based array.")]
    HRESULT _stdcall BusNames([out, retval] VARIANT* Value);
    [propput, id(0x00000005), helpstring("Variant array of strings. Set Bus definitions for each terminal is connected.\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall BusNames([in] VARIANT Value);
    [propget, id(0x00000006), helpstring("Collection of Properties for this Circuit Element (0 based index, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Properties([in] VARIANT Indx, [out, retval] IDSSProperty** Value);
    [propget, id(0x00000007), helpstring("Complex array of voltages at terminals\0it Element (0 based index, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Voltages([out, retval] VARIANT* Value);
    [propget, id(0x00000008), helpstring("Complex array of currents into each conductor of each terminal\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Currents([out, retval] VARIANT* Value);
    [propget, id(0x00000009), helpstring("Complex array of powers into each conductor of each terminal\0l\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Powers([out, retval] VARIANT* Value);
    [propget, id(0x0000000A), helpstring("Total losses in the element: two-element complex array\0minal\0l\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Losses([out, retval] VARIANT* Value);
    [propget, id(0x0000000B), helpstring("Complex array of losses by phase\0element complex array\0minal\0l\0x, if numeric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PhaseLosses([out, retval] VARIANT* Value);
    [propget, id(0x0000000C), helpstring("Double array of symmetrical component voltages at each 3-phase terminal\0eric)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqVoltages([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("Double array of symmetrical component currents into each 3-phase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqCurrents([out, retval] VARIANT* Value);
    [propget, id(0x0000000E), helpstring("Double array of sequence powers into each 3-phase teminal\0-phase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqPowers([out, retval] VARIANT* Value);
    [propget, id(0x0000000F), helpstring("Boolean indicating that element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Enabled([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x0000000F), helpstring("Boolean indicating that element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Enabled([in] VARIANT_BOOL Value);
    [propget, id(0x00000010), helpstring("Normal ampere rating for PD Elements")]
    HRESULT _stdcall NormalAmps([out, retval] double* Value);
    [propput, id(0x00000010), helpstring("Normal ampere rating\0at element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormalAmps([in] double Value);
    [propget, id(0x00000011), helpstring("Emergency Ampere Rating for PD elements")]
    HRESULT _stdcall EmergAmps([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Emergency Ampere Rating\0element is currently in the circuit.\0ase terminal\0ic)\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergAmps([in] double Value);
    [id(0x00000012), helpstring("Open the specified terminal and phase, if non-zero.  Else all conductors at terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Open([in] long Term, [in] long Phs);
    [id(0x00000013), helpstring("Close the specified terminal and phase, if non-zero.  Else all conductors at terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Close([in] long Term, [in] long Phs);
    [id(0x00000014), helpstring("Boolean indicating if the specified terminal and, optionally, phase is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsOpen([in] long Term, [in] long Phs, [out, retval] VARIANT_BOOL* Value);
    [propget, id(0x00000015), helpstring("Number of Properties this Circuit Element.\0l and, optionally, phase is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumProperties([out, retval] long* Value);
    [propget, id(0x00000016), helpstring("Variant array containing all property names of the active device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllPropertyNames([out, retval] VARIANT* Value);
    [propget, id(0x00000017), helpstring("Residual currents for each terminal: (mag, angle)\0 active device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Residuals([out, retval] VARIANT* Value);
    [propget, id(0x00000018), helpstring("YPrim matrix, column order, complex numbers (paired)\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Yprim([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Display name of the object (not necessarily unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DisplayName([out, retval] BSTR* Value);
    [propput, id(0x000000C9), helpstring("Display name of the object (not necessarily unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DisplayName([in] BSTR Value);
    [propget, id(0x000000CA), helpstring("Pointer to this object\0ect (not necessarily unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Handle([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("globally unique identifier for this object\0 unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GUID([out, retval] BSTR* Value);
    [propget, id(0x000000CC), helpstring("This element has a SwtControl attached.\0ct\0 unique)\0\0tive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall HasSwitchControl([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CD), helpstring("This element has a CapControl or RegControl attached.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall HasVoltControl([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CE), helpstring("Name of the Energy Meter this element is assigned to.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EnergyMeter([out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Full name of the i-th controller attached to this element. Ex: str = Controller(2).  See NumControls to determine valid index range")]
    HRESULT _stdcall Controller([in] long idx, [out, retval] BSTR* Value);
    [propget, id(0x000000D0), helpstring("Complex double array of Sequence Voltage for all terminals of active circuit element.")]
    HRESULT _stdcall CplxSeqVoltages([out, retval] VARIANT* Value);
    [propget, id(0x000000D1), helpstring("Complex double array of Sequence Currents for all conductors of all terminals of active circuit element.")]
    HRESULT _stdcall CplxSeqCurrents([out, retval] VARIANT* Value);
    [propget, id(0x000000D2), helpstring("Variant array of strings listing all the published variable names, if a PCElement. Otherwise, null string.")]
    HRESULT _stdcall AllVariableNames([out, retval] VARIANT* Value);
    [propget, id(0x000000D3), helpstring("Variant array of doubles. Values of state variables of active element if PC element.")]
    HRESULT _stdcall AllVariableValues([out, retval] VARIANT* Value);
    [propget, id(0x000000D4), helpstring("For PCElement, get the value of a variable by name. If Code>0 Then no variable by this name or not a PCelement.")]
    HRESULT _stdcall Variable([in] BSTR MyVarName, [out] long* Code, [out, retval] double* Value);
    [propget, id(0x000000D5), helpstring("For PCElement, get the value of a variable by integer index.")]
    HRESULT _stdcall Variablei([in] long Idx, [out] long* Code, [out, retval] double* Value);
    [propget, id(0x000000D6), helpstring("Variant array of integer containing the node numbers (representing phases, for example) for each conductor of each terminal. ")]
    HRESULT _stdcall NodeOrder([out, retval] VARIANT* Value);
    [propget, id(0x000000D7), helpstring("True if a recloser, relay, or fuse controlling this ckt element. OCP = Overcurrent Protection ")]
    HRESULT _stdcall HasOCPDevice([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000D8), helpstring("Number of controls connected to this device. Use to determine valid range for index into Controller array.")]
    HRESULT _stdcall NumControls([out, retval] long* Value);
    [propget, id(0x000000D9), helpstring("Index into Controller list of OCP Device controlling this CktElement")]
    HRESULT _stdcall OCPDevIndex([out, retval] long* Value);
    [propget, id(0x000000DA), helpstring("0=None; 1=Fuse; 2=Recloser; 3=Relay;  Type of OCP controller device")]
    HRESULT _stdcall OCPDevType([out, retval] long* Value);
    [propget, id(0x000000DB), helpstring("Currents in magnitude, angle format as a variant array of doubles.")]
    HRESULT _stdcall CurrentsMagAng([out, retval] VARIANT* Value);
    [propget, id(0x000000DC), helpstring("Voltages at each conductor in magnitude, angle form as variant array of doubles.")]
    HRESULT _stdcall VoltagesMagAng([out, retval] VARIANT* Value);
  };

  [
    uuid(B521E339-8ED2-4BD6-9AEB-FD349CA8D8E3),
    version(1.0),
    helpstring("Dispatch interface for Errror Object\0ect\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IError: IDispatch
  {
    [propget, id(0x00000001), helpstring("Error Number\0the controller attached to this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Number([out, retval] long* Number);
    [propget, id(0x00000002), helpstring("Description of error for last operation\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Description([out, retval] BSTR* Description);
  };

  [
    uuid(32441C6D-7A27-4164-B5B0-FA054300C217),
    version(1.0),
    helpstring("Dispatch interface for Circuit Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface ICircuit: IDispatch
  {
    [propget, id(0x00000001), helpstring("Name of the active circuit.\0t operation\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propget, id(0x00000002), helpstring("Number of CktElements in the circuit.\0n\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumCktElements([out, retval] long* Value);
    [propget, id(0x00000003), helpstring("Total number of Buses in the circuit.\0n\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumBuses([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Total number of nodes in the circuit.\0n\0this element.\0ive device.\0e is open.\0terminal.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumNodes([out, retval] long* Value);
    [propget, id(0x00000005), helpstring("Collection of Buses in the circuit. Index may be string or integer index (0 based).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Buses([in] VARIANT Index, [out, retval] IBus** Value);
    [propget, id(0x00000006), helpstring("Collection of CktElements in Circuit\0ndex may be string or integer index (0 based).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CktElements([in] VARIANT Idx, [out, retval] ICktElement** Value);
    [propget, id(0x00000007), helpstring("Total losses in active circuit, complex number (two-element array of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Losses([out, retval] VARIANT* Value);
    [propget, id(0x00000008), helpstring("Complex total line losses in the circuit\0umber (two-element array of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LineLosses([out, retval] VARIANT* Value);
    [propget, id(0x00000009), helpstring("Complex losses in all transformers designated to substations.\0ray of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SubstationLosses([out, retval] VARIANT* Value);
    [propget, id(0x0000000A), helpstring("Total power, watts delivered to the circuit\0d to substations.\0ray of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TotalPower([out, retval] VARIANT* Value);
    [propget, id(0x0000000B), helpstring("Complex array of all bus, node voltages from most recent solution\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusVolts([out, retval] VARIANT* Value);
    [propget, id(0x0000000C), helpstring("Array of magnitudes (doubles) of voltages at all buses\0t solution\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusVmag([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("Vaiant array of strings containing Full Name of all elements.\0ion\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllElementNames([out, retval] VARIANT* Value);
    [propget, id(0x0000000E), helpstring("Return an interface to the active circuit element\0l elements.\0ion\0of double).\0sed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveElement([out, retval] ICktElement** Value);
    [id(0x0000000F), helpstring("Disable a circuit element by name (removes from circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Disable([in] BSTR Name);
    [id(0x00000010), helpstring("Activate (enable) a disabled device.\0moves from circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Enable([in] BSTR Name);
    [propget, id(0x00000011), helpstring("Return an interface to the Solution object.\0rom circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Solution([out, retval] ISolution** Value);
    [propget, id(0x00000012), helpstring("Return an interface to the active bus.\0ect.\0rom circuit but leave in database)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveBus([out, retval] IBus** Value);
    [id(0x00000013), helpstring("Sets the first Power Conversion (PC) element to be the active element.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FirstPCElement([out, retval] long* Value);
    [id(0x00000014), helpstring("Gets next PC Element.  Returns 0 if no more.\0to be the active element.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NextPCElement([out, retval] long* Value);
    [id(0x00000015), helpstring("Sets the first Power Delivery (PD) element to be the active element.\0.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FirstPDElement([out, retval] long* Value);
    [id(0x00000016), helpstring("Gets next PD Element. Returns 0 if no more.\0o be the active element.\0.\0tabase)\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NextPDElement([out, retval] long* Value);
    [propget, id(0x00000017), helpstring("Array of strings containing names of all buses in circuit (see AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusNames([out, retval] VARIANT* Value);
    [propget, id(0x00000018), helpstring("Array of total losses (complex) in each circuit element\0t (see AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllElementLosses([out, retval] VARIANT* Value);
    [id(0x00000019), helpstring("Force all Meters and Monitors to take a sample.\0element\0t (see AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample(void);
    [id(0x0000001A), helpstring("Force all meters and monitors to save their current buffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SaveSample(void);
    [propget, id(0x0000001B), helpstring("Returns interface to Monitors collection.\0r current buffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Monitors([out, retval] IMonitors** Value);
    [propget, id(0x0000001C), helpstring("Returns interface to Meters (EnergyMeter) collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Meters([out, retval] IMeters** Value);
    [propget, id(0x0000001D), helpstring("Returns a Generators Object interface\0er) collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Generators([out, retval] IGenerators** Value);
    [propget, id(0x0000001E), helpstring("Returns interface to Settings interface.\0 collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Settings([out, retval] ISettings** Value);
    [propget, id(0x0000001F), helpstring("Returns Interface to Lines collection.\0.\0 collection.\0ffers.\0e AllNodeNames).\0\0ed).\0l.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Lines([out, retval] ILines** Value);
    [id(0x00000020), helpstring("Sets the Active Circuit Element using the full object name (e.g. \"generator.g1\"). Returns -1 if not found. Else index to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveElement([in] BSTR FullName, [out, retval] long* Value);
    [id(0x00000021)]
    HRESULT _stdcall Capacity([in] double Start, [in] double Increment, [out, retval] double* Value);
    [id(0x00000022), helpstring("Sets Active bus by name. Ignores node list.  Returns bus index (zero based) compatible with AllBusNames and Buses collection.")]
    HRESULT _stdcall SetActiveBus([in] BSTR BusName, [out, retval] long* Value);
    [id(0x00000024), helpstring("Sets ActiveBus by Integer value.  0-based index compatible with SetActiveBus return value and AllBusNames indexing. Returns 0 if OK.")]
    HRESULT _stdcall SetActiveBusi([in] long BusIndex, [out, retval] long* Value);
    [propget, id(0x00000023), helpstring("Double Array of all bus voltages (each node) magnitudes in Per unit\0with AllBusNames and Buses collection.\0Else index to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusVmagPu([out, retval] VARIANT* Value);
    [propget, id(0x00000025), helpstring("Variant array of strings containing full name of each node in system in same order as returned by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeNames([out, retval] VARIANT* Value);
    [propget, id(0x00000026), helpstring("System Y matrix (after a solution has been performed)\0node in system in same order as returned by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SystemY([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Interface to the main Control Queue\0s been performed)\0node in system in same order as returned by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CtrlQueue([out, retval] ICtrlQueue** Value);
    [propget, id(0x000000CA), helpstring("Returns distance from each bus to parent EnergyMeter. Corresponds to sequence in AllBusNames.\0 by AllBusVolts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBusDistances([out, retval] VARIANT* Value);
    [propget, id(0x000000CB), helpstring("Returns an array of distances from parent EnergyMeter for each Node. Corresponds to AllBusVMag sequence.\0olts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeDistances([out, retval] VARIANT* Value);
    [propget, id(0x000000CC), helpstring("Returns Array of doubles represent voltage magnitudes for nodes on the specified phase.\0usVMag sequence.\0olts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeVmagByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000CD), helpstring("Returns array of per unit voltage magnitudes for each node by phase\0he specified phase.\0usVMag sequence.\0olts, etc.\0x to be used in CktElements collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeVmagPUByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("Returns an array of doubles representing the distances to parent EnergyMeter. Sequence of array corresponds to other node ByPhase properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeDistancesByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000CF), helpstring("Return variant array of strings of the node names for the By Phase criteria. Sequence corresponds to other ByPhase properties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNodeNamesByPhase([in] long Phase, [out, retval] VARIANT* Value);
    [propget, id(0x000000D0), helpstring("Returns interface to Load element interface\0names for the By Phase criteria. Sequence corresponds to other ByPhase properties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Loads([out, retval] ILoads** Value);
    [id(0x000000D1), helpstring("Sets First element of active class to be the Active element in the active circuit. Returns 0 if none.\0ther ByPhase properties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FirstElement([out, retval] long* Value);
    [id(0x000000D2), helpstring("Sets the next element of the active class to be the active element in the active circuit. Returns 0 if no more elements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NextElement([out, retval] long* Value);
    [id(0x000000D3), helpstring("Sets the active class by name.  Use FirstElement, NextElement to iterate through the class. Returns -1 if fails.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveClass([in] BSTR ClassName, [out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("Returns Interface to the Active DSS object, which could be either a circuit element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveDSSElement([out, retval] IDSSElement** Value);
    [propget, id(0x000000D5), helpstring("Returns interface to the Active Circuit element (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveCktElement([out, retval] ICktElement** Value);
    [propget, id(0x000000D6), helpstring("Returns interface to active class.\0cuit element (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveClass([out, retval] IActiveClass** Value);
    [propget, id(0x000000D7), helpstring("Returns interface to Transformers collection\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Transformers([out, retval] ITransformers** Value);
    [propget, id(0x000000D8), helpstring("Returns interface to SwtControls collection.\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwtControls([out, retval] ISwtControls** Value);
    [propget, id(0x000000D9), helpstring("Returns interface to CapControls collection\0\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CapControls([out, retval] ICapControls** Value);
    [propget, id(0x000000DA), helpstring("Returns interfact to RegControls collection\0\0nt (same as ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegControls([out, retval] IRegControls** Value);
    [propget, id(0x000000DB), helpstring("Interface to the active circuit's Capacitors collection.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capacitors([out, retval] ICapacitors** Value);
    [propget, id(0x000000DC), helpstring("Interface to the active circuit's topology object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Topology([out, retval] ITopology** Value);
    [propget, id(0x000000DD), helpstring("Interface to Sensors in the Active Circuit.")]
    HRESULT _stdcall Sensors([out, retval] ISensors** Value);
    [id(0x000000DE), helpstring("Forces update to all storage classes. Typically done after a solution. Done automatically in intrinsic solution modes.")]
    HRESULT _stdcall UpdateStorage(void);
    [propget, id(0x000000DF), helpstring("Sets Parent PD element, if any, to be the active circuit element and returns index>0; Returns 0 if it fails or not applicable.")]
    HRESULT _stdcall ParentPDElement([out, retval] long* Value);
    [propget, id(0x000000E0), helpstring("Interface to XYCurves in active circuit.")]
    HRESULT _stdcall XYCurves([out, retval] IXYCurves** Value);
    [propget, id(0x000000E1), helpstring("Interface to PDElements collection")]
    HRESULT _stdcall PDElements([out, retval] IPDElements** Value);
    [propget, id(0x000000E2)]
    HRESULT _stdcall Reclosers([out, retval] IReclosers** Value);
    [propget, id(0x000000E3)]
    HRESULT _stdcall Relays([out, retval] IRelays** Value);
    [propget, id(0x000000E4), helpstring("Interface to OpenDSS Load shapes currently defined.")]
    HRESULT _stdcall LoadShapes([out, retval] ILoadShapes** Value);
    [propget, id(0x000000E5), helpstring("Return interface to Fuses ")]
    HRESULT _stdcall Fuses([out, retval] Fuses** Value);
    [propget, id(0x000000E6), helpstring("Interface to ISOURCE devices")]
    HRESULT _stdcall Isources([out, retval] IISources** Value);
    [propget, id(0x000000E7), helpstring("Complex array of actual node voltages in same order as SystemY matrix.")]
    HRESULT _stdcall YNodeVarray([out, retval] VARIANT* Value);
    [id(0x000000E8), helpstring("Calls EndOfTimeStepCleanup in SolutionAlgs")]
    HRESULT _stdcall EndOfTimeStepUpdate(void);
    [propget, id(0x000000E9)]
    HRESULT _stdcall DSSim_Coms([out, retval] IDSSimComs** Value);
    [propget, id(0x000000EA), helpstring("Variant array of strings containing the names of the nodes in the same order as the Y matrix")]
    HRESULT _stdcall YNodeOrder([out, retval] VARIANT* Value);
    [propget, id(0x000000EB), helpstring("Variant array of doubles containing complex injection currents for the present solution. Is is the \"I\" vector of I=YV")]
    HRESULT _stdcall YCurrents([out, retval] VARIANT* Value);
    [propget, id(0x000000EC), helpstring("Interface to PVSystems collection")]
    HRESULT _stdcall PVSystems([out, retval] IPVSystems** Value);
    [propget, id(0x000000ED), helpstring("Vsources object collection")]
    HRESULT _stdcall Vsources([out, retval] IVsources** Value);
  };

  [
    uuid(E5B78C35-88F8-495F-8CD1-EBB5D90ED228),
    version(1.0),
    helpstring("Dispatch interface for Bus Object\0ect\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IBus: IDispatch
  {
    [propget, id(0x00000001), helpstring("Name of Bus\0 the active circuit's topology object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Name);
    [propget, id(0x00000002), helpstring("Number of Nodes this bus.\0rcuit's topology object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumNodes([out, retval] long* NumNodes);
    [propget, id(0x00000003), helpstring("Complex array of voltages at this bus.\0ogy object.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Voltages([out, retval] VARIANT* Voltages);
    [propget, id(0x00000004), helpstring("Double Array of sequence voltages at this bus.\0ct.\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SeqVoltages([out, retval] VARIANT* SeqVoltages);
    [propget, id(0x00000005), helpstring("Integer Array of Node Numbers defined at the bus in same order as the voltages.")]
    HRESULT _stdcall Nodes([out, retval] VARIANT* Nodes);
    [propget, id(0x00000006), helpstring("Open circuit voltage; Complex array.\0 at the bus.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Voc([out, retval] VARIANT* Voc);
    [propget, id(0x00000007), helpstring("Short circuit currents at bus; Complex Array.\0us.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Isc([out, retval] VARIANT* Isc);
    [propget, id(0x00000008), helpstring("Complex Array of pu voltages at the bus.\0ray.\0us.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall puVoltages([out, retval] VARIANT* Value);
    [propget, id(0x00000009), helpstring("Base voltage at bus in kV\0es at the bus.\0ray.\0us.\0\0tion.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kVBase([out, retval] double* Value);
    [propget, id(0x0000000A), helpstring("Complex array of Zsc matrix at bus. Column by column.\0n.\0ActiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZscMatrix([out, retval] VARIANT* Value);
    [propget, id(0x0000000B), helpstring("Complex Positive-Sequence short circuit impedance at bus..\0tiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Zsc1([out, retval] VARIANT* Value);
    [propget, id(0x0000000C), helpstring("Complex Zero-Sequence short circuit impedance at bus.\0us..\0tiveElement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Zsc0([out, retval] VARIANT* Value);
    [id(0x0000000D), helpstring("Recomputes Zsc for active bus for present circuit configuration.\0ement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZscRefresh([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x0000000E), helpstring("Complex array of Ysc matrix at bus. Column by column.\0iguration.\0ement).\0it element or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall YscMatrix([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("False=0 else True. Indicates whether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Coorddefined([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CA), helpstring("X Coordinate for bus (double)\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall x([out, retval] double* Value);
    [propput, id(0x000000CA), helpstring("X Coordinate for bus (double)\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall x([in] double Value);
    [propget, id(0x000000CB), helpstring("Y coordinate for bus(double)\0\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall y([out, retval] double* Value);
    [propput, id(0x000000CB), helpstring("Y coordinate for bus(double)\0\0hether a coordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall y([in] double Value);
    [propget, id(0x000000CC), helpstring("Distance from energymeter (if non-zero)\0oordinate has been defined for this bus\0ent or a general DSS element.\0s.\0ements.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Distance([out, retval] double* Value);
    [id(0x000000CD), helpstring("Returns a unique node number at the active bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GetUniqueNodeNumber([in] long StartNumber, [out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Complex Double array of Sequence Voltages (0, 1, 2) at this Bus.")]
    HRESULT _stdcall CplxSeqVoltages([out, retval] VARIANT* Value);
    [propget, id(0x000000CF), helpstring("Accumulated failure rate downstream from this bus; faults per year")]
    HRESULT _stdcall Lambda([out, retval] double* Value);
    [propget, id(0x000000D0), helpstring("Number of interruptions this bus per year")]
    HRESULT _stdcall N_interrupts([out, retval] double* Value);
    [propget, id(0x000000D1), helpstring("Average interruption duration, hr.")]
    HRESULT _stdcall Int_Duration([out, retval] double* Value);
    [propget, id(0x000000D2), helpstring("Annual number of customer-interruptions from this bus")]
    HRESULT _stdcall Cust_Interrupts([out, retval] double* Value);
    [propget, id(0x000000D3), helpstring("Accumulated customer outage durations")]
    HRESULT _stdcall Cust_Duration([out, retval] double* Value);
    [propget, id(0x000000D4), helpstring("Total numbers of customers served downline from this bus")]
    HRESULT _stdcall N_Customers([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("For 2- and 3-phase buses, returns variant array of complex numbers represetin L-L voltages in volts. Returns -1.0 for 1-phase bus. If more than 3 phases, returns only first 3.")]
    HRESULT _stdcall VLL([out, retval] VARIANT* Value);
    [propget, id(0x000000D6), helpstring("Returns Complex array of pu L-L voltages for 2- and 3-phase buses. Returns -1.0 for 1-phase bus. If more than 3 phases, returns only 3 phases.")]
    HRESULT _stdcall puVLL([out, retval] VARIANT* Value);
    [propget, id(0x000000D7), helpstring("Variant Array of doubles containing voltages in Magnitude (VLN), angle (deg) ")]
    HRESULT _stdcall VMagAngle([out, retval] VARIANT* Value);
    [propget, id(0x000000D8), helpstring("Variant array of doubles containig voltage magnitude, angle pairs in per unit")]
    HRESULT _stdcall puVmagAngle([out, retval] VARIANT* Value);
    [propget, id(0x000000D9), helpstring("Total length of line downline from this bus, in miles. For recloser siting algorithm.")]
    HRESULT _stdcall TotalMiles([out, retval] double* Value);
    [propget, id(0x000000DA), helpstring("Integer ID of the feeder section in which this bus is located.")]
    HRESULT _stdcall SectionID([out, retval] long* Value);
  };

  [
    uuid(14644AD0-4909-48FF-B624-24E8C38D1AED),
    version(1.0),
    helpstring("Dispatch interface for DSSMain Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface IDSS: IDispatch
  {
    [propget, id(0x00000001), helpstring("Number of Circuits currently defined\0ctive bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumCircuits([out, retval] long* Value);
    [propget, id(0x00000002), helpstring("Collection of Circuit objects\0efined\0ctive bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Circuits([in] VARIANT Idx, [out, retval] ICircuit** Value);
    [propget, id(0x00000003), helpstring("Returns interface to the active circuit.\0e bus to avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveCircuit([out, retval] ICircuit** Value);
    [propget, id(0x00000004), helpstring("Returns the DSS Text (command-result) interface.\0 avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Text([out, retval] IText** Value);
    [propget, id(0x00000005), helpstring("Returns Error interface.\0mand-result) interface.\0 avoid node collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Error([out, retval] IError** Value);
    [id(0x00000006), helpstring("Make a new circuit and return interface to active circuit.\0e collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NewCircuit([in] BSTR Name, [out, retval] ICircuit** Value);
    [id(0x00000007), helpstring("Clears all circuit definitions.\0terface to active circuit.\0e collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ClearAll(void);
    [id(0x00000008), helpstring("Shows non-MDI child form of the Main DSS Edit Form\0ircuit.\0e collisions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ShowPanel(void);
    [id(0x00000009), helpstring("Validate the user and start the DSS. Returns TRUE if successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Start([in] long code, [out, retval] VARIANT_BOOL* Value);
    [propget, id(0x0000000A), helpstring("Get version string for the DSS.\0DSS. Returns TRUE if successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Version([out, retval] BSTR* Value);
    [propget, id(0x0000000B), helpstring("Gets interface to the DSS Progress Meter\0rns TRUE if successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DSSProgress([out, retval] IDSSProgress** Value);
    [propget, id(0x0000000C), helpstring("List of DSS intrinsic classes (names of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Classes([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("List of user-defined classes\0 (names of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UserClasses([out, retval] VARIANT* Value);
    [propget, id(0x0000000E), helpstring("Number of DSS intrinsic classes\0ames of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumClasses([out, retval] long* Value);
    [propget, id(0x0000000F), helpstring("Number of user-defined classes\0\0ames of the classes)\0successful.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumUserClasses([out, retval] long* Value);
    [propget, id(0x00000011), helpstring("DSS Data File Path.  Default path for reports, etc. from DSS\0ul.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DataPath([out, retval] BSTR* Value);
    [propput, id(0x00000011), helpstring("DSS Data File Path.  Default path for reports, etc. from DSS\0ul.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DataPath([in] BSTR Value);
    [id(0x00000012), helpstring("Resets DSS Initialization for restarts, etc from applets\0DSS\0ul.\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Reset(void);
    [propget, id(0x00000014), helpstring("Default is TRUE. Use this to set to FALSE; Cannot reset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowForms([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000014), helpstring("Default is TRUE. Use this to set to FALSE; Cannot reset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowForms([in] VARIANT_BOOL Value);
    [propget, id(0x000000C9), helpstring("Returns the path name for the default text editor.\0eset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultEditor([out, retval] BSTR* Value);
    [propget, id(0x000000CA), helpstring("Returns interface to the active class.\0ext editor.\0eset to TRUE;\0isions and adds it to the node list for the bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveClass([out, retval] IActiveClass** Value);
    [id(0x000000CB), helpstring("Sets the Active DSS Class for use with ActiveClass interface. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SetActiveClass([in] BSTR ClassName, [out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Interface to DSS Executive commands and options\0ss interface. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Executive([out, retval] IDSS_Executive** Value);
    [propget, id(0x000000CE), helpstring("Interface to the DSS Events")]
    HRESULT _stdcall Events([out, retval] IDSSEvents** Value);
    [propget, id(0x000000CC), helpstring("Returns an interface to the complex math library.")]
    HRESULT _stdcall CmathLib([out, retval] ICmathLib** Value);
    [propget, id(0x000000CF), helpstring("Returns interface to the OpenDSS Parser library for use by user-written programs.")]
    HRESULT _stdcall Parser([out, retval] IParser** Value);
    [propget, id(0x000000D0)]
    HRESULT _stdcall DSSim_Coms([out, retval] IDSSimComs** Value);
  };

  [
    uuid(F2332365-962A-4DF4-9D1E-218E0B0F2CEF),
    version(1.0),
    helpstring("Dispatch interface for Solution Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    hidden,
    dual,
    oleautomation
  ]
  interface ISolution: IDispatch
  {
    [id(0x00000001), helpstring("Execute solution for present solution mode.\0ons\0ss interface. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Solve(void);
    [propget, id(0x00000002), helpstring("Set present solution mode (by a text code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([out, retval] long* Mode);
    [propput, id(0x00000002), helpstring("Set present solution mode (by a text code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([in] long Mode);
    [propget, id(0x00000003), helpstring("Set the Frequency for next solution\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Frequency([out, retval] double* Frequency);
    [propput, id(0x00000003), helpstring("Set the Frequency for next solution\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Frequency([in] double Frequency);
    [propget, id(0x00000004), helpstring("Set Hour for time series solutions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Hour([out, retval] long* Hour);
    [propput, id(0x00000004), helpstring("Set Hour for time series solutions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Hour([in] long Hour);
    [propget, id(0x00000005), helpstring("Seconds from top of the hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Seconds([out, retval] double* Seconds);
    [propput, id(0x00000005), helpstring("Seconds from top of the hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Seconds([in] double Seconds);
    [propget, id(0x00000006), helpstring("Time step size in sec\0e hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepSize([out, retval] double* StepSize);
    [propput, id(0x00000006), helpstring("Time step size in sec\0e hour.\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepSize([in] double StepSize);
    [propget, id(0x00000007), helpstring("Set year for planning studies\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Year([out, retval] long* Year);
    [propput, id(0x00000007), helpstring("Set year for planning studies\0ions.\0 code - see DSS Help)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Year([in] long Year);
    [propget, id(0x00000008), helpstring("Default load multiplier applied to all non-fixed loads\0p)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadMult([out, retval] double* LoadMult);
    [propput, id(0x00000008), helpstring("Default load multiplier applied to all non-fixed loads\0p)\0ce. Same as SetActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadMult([in] double LoadMult);
    [propget, id(0x00000009), helpstring("Number of iterations taken for last solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Iterations([out, retval] long* Iterations);
    [propget, id(0x0000000A), helpstring("Max allowable iterations.\0 for last solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxIterations([out, retval] long* MaxIterations);
    [propput, id(0x0000000A), helpstring("Max allowable iterations.\0 for last solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxIterations([in] long MaxIterations);
    [propget, id(0x0000000B), helpstring("Solution convergence tolerance.\0ast solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tolerance([out, retval] double* Tolerance);
    [propput, id(0x0000000B), helpstring("Solution convergence tolerance.\0ast solution. (Same as TotalIterations)\0tActiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tolerance([in] double Tolerance);
    [propget, id(0x0000000C), helpstring("Number of solutions to perform for Monte Carlo and time series simulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Number([out, retval] long* Number);
    [propput, id(0x0000000C), helpstring("Number of solutions to perform for Monte Carlo and time series simulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Number([in] long Number);
    [propget, id(0x0000000D), helpstring("Randomization mode for random variables \"Gaussian\" or \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Random([out, retval] long* Random);
    [propput, id(0x0000000D), helpstring("Randomization mode for random variables \"Gaussian\" or \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Random([in] long Random);
    [propget, id(0x0000000E), helpstring("ID (text) of the present solution mode\0 \"Gaussian\" or \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ModeID([out, retval] BSTR* Value);
    [propget, id(0x0000000F), helpstring("Load Model: {dssPowerFlow (default) | dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadModel([out, retval] long* Value);
    [propput, id(0x0000000F), helpstring("Load Model: {dssPowerFlow (default) | dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LoadModel([in] long Value);
    [propget, id(0x00000010), helpstring("Load-Duration Curve name for LD modes\0dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LDCurve([out, retval] BSTR* Value);
    [propput, id(0x00000010), helpstring("Load-Duration Curve name for LD modes\0dssAdmittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LDCurve([in] BSTR Value);
    [propget, id(0x00000011), helpstring("Percent default  annual load growth rate\0Admittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall pctGrowth([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Percent default  annual load growth rate\0Admittance}\0 \"Uniform\"\0imulations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall pctGrowth([in] double Value);
    [propget, id(0x00000012), helpstring("Type of device to add in AutoAdd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AddType([out, retval] long* Value);
    [propput, id(0x00000012), helpstring("Type of device to add in AutoAdd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AddType([in] long Value);
    [propget, id(0x00000013), helpstring("Generator kW for AutoAdd mode\0dd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenkW([out, retval] double* Value);
    [propput, id(0x00000013), helpstring("Generator kW for AutoAdd mode\0dd Mode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenkW([in] double Value);
    [propget, id(0x00000014), helpstring("PF for generators in AutoAdd mode\0ode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenPF([out, retval] double* Value);
    [propput, id(0x00000014), helpstring("PF for generators in AutoAdd mode\0ode: {dssGen (Default) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenPF([in] double Value);
    [propget, id(0x00000015), helpstring("Capacitor kvar for adding capacitors in AutoAdd mode\0lt) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capkvar([out, retval] double* Value);
    [propput, id(0x00000015), helpstring("Capacitor kvar for adding capacitors in AutoAdd mode\0lt) | dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capkvar([in] double Value);
    [propget, id(0x00000016), helpstring("Base Solution algorithm: {dssNormalSolve | dssNewtonSolve}\0dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Algorithm([out, retval] long* Value);
    [propput, id(0x00000016), helpstring("Base Solution algorithm: {dssNormalSolve | dssNewtonSolve}\0dssCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Algorithm([in] long Value);
    [propget, id(0x00000017), helpstring("{dssStatic* | dssEvent | dssTime}  Modes for control devices\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlMode([out, retval] long* Value);
    [propput, id(0x00000017), helpstring("{dssStatic* | dssEvent | dssTime}  Modes for control devices\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlMode([in] long Value);
    [propget, id(0x00000018), helpstring("Default Multiplier applied to generators (like LoadMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenMult([out, retval] double* Value);
    [propput, id(0x00000018), helpstring("Default Multiplier applied to generators (like LoadMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall GenMult([in] double Value);
    [propget, id(0x00000019), helpstring("Default daily load shape (defaults to \"Default\")\0adMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultDaily([out, retval] BSTR* Value);
    [propput, id(0x00000019), helpstring("Default daily load shape (defaults to \"Default\")\0adMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultDaily([in] BSTR Value);
    [propget, id(0x0000001A), helpstring("Default Yearly load shape (defaults to \"Default\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultYearly([out, retval] BSTR* Value);
    [propput, id(0x0000001A), helpstring("Default Yearly load shape (defaults to \"Default\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DefaultYearly([in] BSTR Value);
    [propget, id(0x0000001B), helpstring("Array of strings containing the Event Log\0fault\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EventLog([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Hour as a double, including fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall dblHour([out, retval] double* Value);
    [propput, id(0x000000C9), helpstring("Hour as a double, including fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall dblHour([in] double Value);
    [propput, id(0x000000CA), helpstring("Set Stepsize in minutes\0ing fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepsizeMin([in] double Param1);
    [propput, id(0x000000CB), helpstring("Set Stepsize in Hr\0utes\0ing fractional part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall StepsizeHr([in] double Param1);
    [propget, id(0x000000CC), helpstring("Value of the control iteration counter\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlIterations([out, retval] long* Value);
    [propput, id(0x000000CC), helpstring("Value of the control iteration counter\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlIterations([in] long Value);
    [propget, id(0x000000CD), helpstring("Maximum allowable control iterations\0r\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxControlIterations([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Maximum allowable control iterations\0r\0part\0ult\")\0dMult)\0ces\0sCap}\0lations\0tiveClass in Circuit interface.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxControlIterations([in] long Value);
    [id(0x000000CE), helpstring("Sample controls and then process the control queue for present control mode and dispatch control actions\0.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample_DoControlActions(void);
    [id(0x000000CF), helpstring("Executes status check on all fault objects defined in the circuit.\0rol mode and dispatch control actions\0.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CheckFaultStatus(void);
    [id(0x000000D0), helpstring("Execute the snapshot power flow routine in the DSS that solves at the present state with control actions\0.\0e bus.\0ments.\0ties.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolveSnap(void);
    [id(0x000000D1), helpstring("Executes a direct solution from the system Y matrix, ignoring compensation currents of loads, generators (includes Yprim only)\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolveDirect(void);
    [id(0x000000D2), helpstring("Solves using present power flow method. Iterative solution rather than direct solution.\0oads, generators (includes Yprim only)\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolvePflow(void);
    [id(0x000000D3), helpstring("Similar to SolveSnap except no control actions are checked or executed\0direct solution.\0oads, generators (includes Yprim only)\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolveNoControl(void);
    [id(0x000000D4), helpstring("Executes a power flow solution (SolveNoControl) plus executes a CheckControlActions that executes any pending control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SolvePlusControl(void);
    [id(0x000000D5), helpstring("Initializes some variables for snap shot power flow. SolveSnap does this automatically.\0 executes any pending control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall InitSnap(void);
    [id(0x000000D6), helpstring("The normal process for sampling and executing Control Actions and Fault Status and rebuilds Y if necessary.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CheckControls(void);
    [id(0x000000D7), helpstring("Executes a sampling of all intrinsic control devices, which push control actions onto the control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleControlDevices(void);
    [id(0x000000D8), helpstring("Pops control actions off the control queue and dispatches to the proper control element\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DoControlActions(void);
    [id(0x000000D9), helpstring("Force building of the System Y matrix\0ueue and dispatches to the proper control element\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall BuildYMatrix([in] long BuildOption, [in] long AllocateVI);
    [propget, id(0x000000DA), helpstring("Flag that indicates if elements of the System Y have been changed by recent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SystemYChanged([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000DB), helpstring("Flag to indicate whether the circuit solution converged\0n changed by recent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Converged([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000DB), helpstring("Flag to indicate whether the circuit solution converged\0n changed by recent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Converged([in] VARIANT_BOOL Value);
    [propget, id(0x000000DC), helpstring("Total iterations including control iterations for most recent solution.\0ent activity.\0t\0e control queue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Totaliterations([out, retval] long* Value);
    [propget, id(0x000000DD), helpstring("Max number of iterations required to converge at any control iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MostIterationsDone([out, retval] long* Value);
    [propget, id(0x000000DE), helpstring("Flag indicating the control actions are done.")]
    HRESULT _stdcall ControlActionsDone([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000DE)]
    HRESULT _stdcall ControlActionsDone([in] VARIANT_BOOL Value);
    [id(0x000000DF), helpstring("Call Cleanup, sample monitors, and increment time at end of time step.")]
    HRESULT _stdcall FinishTimeStep(void);
    [id(0x000000E0), helpstring("Update storage, invcontrol, etc at end of time step")]
    HRESULT _stdcall Cleanup(void);
    [propget, id(0x000000E1), helpstring("Gets the accumulated time of the simulation")]
    HRESULT _stdcall Total_Time([out, retval] double* Value);
    [propput, id(0x000000E1), helpstring("Sets the Accumulated time of the simulation")]
    HRESULT _stdcall Total_Time([in] double Value);
    [propget, id(0x000000E2), helpstring("Gets the time required to perform the latest solution (Read only)")]
    HRESULT _stdcall Process_Time([out, retval] double* Value);
    [propget, id(0x000000E3), helpstring("Get the solution process time + sample time for time step")]
    HRESULT _stdcall Time_of_Step([out, retval] double* Value);
  };

  [
    uuid(5C339E44-C583-445C-91D1-3B1E49CAD6B0),
    version(1.0),
    helpstring("Dispatch interface for Monitors Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IMonitors: IDispatch
  {
    [propget, id(0x00000002), helpstring("Array of all Monitor Names\0quired to converge at any control iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000003), helpstring("Sets the first Monitor active.  Returns 0 if no monitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Sets next monitor active.  Returns 0 if no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [id(0x00000005), helpstring("Resets active Monitor object.\0urns 0 if no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Reset(void);
    [id(0x00000006), helpstring("Resets all Monitor Objects\0t.\0urns 0 if no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ResetAll(void);
    [id(0x00000007), helpstring("Causes active Monitor to take a sample.\0no more.\0onitors.\0ol iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample(void);
    [id(0x00000008), helpstring("Causes active monitor to save its current sample buffer to its monitor stream. Then you can access the Bytestream or channel data. Most standard solution modes do this automatically.")]
    HRESULT _stdcall Save(void);
    [id(0x00000009), helpstring("Converts monitor file to text and displays with text editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Show(void);
    [propget, id(0x0000000A), helpstring("Name of CSV file associated with active Monitor.\0ext editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall FileName([out, retval] BSTR* Value);
    [propget, id(0x0000000B), helpstring("Set Monitor mode (bitmask integer - see DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([out, retval] long* Value);
    [propput, id(0x0000000B), helpstring("Set Monitor mode (bitmask integer - see DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([in] long Value);
    [propget, id(0x00000001), helpstring("Sets the active Monitor object by name\0 DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x00000001), helpstring("Sets the active Monitor object by name\0 DSS Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x0000000C), helpstring("Byte Array containing monitor stream values. Make sure a \"save\" is done first (standard solution modes do this automatically)")]
    HRESULT _stdcall ByteStream([out, retval] VARIANT* Value);
    [propget, id(0x0000000D), helpstring("Number of Samples in Monitor at Present\0ues\0Help)\0xt editor\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleCount([out, retval] long* Value);
    [id(0x000000C9), helpstring("Causes all Monitors to take a sample of the present state\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleAll(void);
    [id(0x000000CA), helpstring("Save all Monitor buffers to their respective file streams.")]
    HRESULT _stdcall SaveAll(void);
    [propget, id(0x000000CB), helpstring("Number of Monitors\0 to take a sample of the present state\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [id(0x000000CC), helpstring("Post-process monitor samples taken so far, e.g., Pst for mode=4")]
    HRESULT _stdcall Process(void);
    [id(0x000000CD), helpstring("All monitors post-process the data taken so far.")]
    HRESULT _stdcall ProcessAll(void);
    [propget, id(0x000000CE), helpstring("Monitor File Version (integer)")]
    HRESULT _stdcall FileVersion([out, retval] long* Value);
    [propget, id(0x000000CF), helpstring("Size of each record in ByteStream (Integer). Same as NumChannels.")]
    HRESULT _stdcall RecordSize([out, retval] long* Value);
    [propget, id(0x000000D0), helpstring("Header string;  Variant array of strings containing Channel names")]
    HRESULT _stdcall Header([out, retval] VARIANT* Value);
    [propget, id(0x000000D1), helpstring("Variant array of doubles containgin time value in hours for time-sampled monitor values; Empty if frequency-sampled values for harmonics solution  (see dblFreq)")]
    HRESULT _stdcall dblHour([out, retval] VARIANT* Value);
    [propget, id(0x000000D2), helpstring("Variant array of doubles containing frequency values for harmonics mode solutions; Empty for time mode solutions (use dblHour)")]
    HRESULT _stdcall dblFreq([out, retval] VARIANT* Value);
    [propget, id(0x000000D3), helpstring("Variant array of doubles for the specified channel  (usage: MyArray = DSSMonitor.Channel(i)) A Save or SaveAll  should be executed first. Done automatically by most standard solution modes.")]
    HRESULT _stdcall Channel([in] long Index, [out, retval] VARIANT* Value);
    [propget, id(0x000000D4), helpstring("Number of Channels in the active Monitor")]
    HRESULT _stdcall NumChannels([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("Full object name of element being monitored.")]
    HRESULT _stdcall Element([out, retval] BSTR* Value);
    [propput, id(0x000000D5), helpstring("Full object name of element being monitored.")]
    HRESULT _stdcall Element([in] BSTR Value);
    [propget, id(0x000000D6), helpstring("Terminal number of element being monitored")]
    HRESULT _stdcall Terminal([out, retval] long* Value);
    [propput, id(0x000000D6), helpstring("Terminal number of element being monitored.")]
    HRESULT _stdcall Terminal([in] long Value);
  };

  [
    uuid(86705B6C-352A-47F8-A24B-78B750EC3859),
    version(1.0),
    helpstring("Dispatch interface for Meters Object\0t\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IMeters: IDispatch
  {
    [propget, id(0x00000002), helpstring("Array of all energy Meter names\0mple of the present state\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000003), helpstring("Set the first energy Meter active. Returns 0 if none.\0ate\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000004), helpstring("Sets the next energy Meter active.  Returns 0 if no more.\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x00000005), helpstring("Array of strings containing the names of the registers.\0.\0r\0\0iteration of the most recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterNames([out, retval] VARIANT* Value);
    [propget, id(0x00000006), helpstring("Array of all the values contained in the Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterValues([out, retval] VARIANT* Value);
    [id(0x00000007), helpstring("Resets registers of active Meter.\0in the Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Reset(void);
    [id(0x00000008), helpstring("Resets registers of all Meter objects.\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ResetAll(void);
    [id(0x00000009), helpstring("Forces active Meter to take a sample.\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Sample(void);
    [id(0x0000000A), helpstring("Saves meter register values.\0 sample.\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Save(void);
    [propget, id(0x0000000C), helpstring("Get/Set the active meter  name.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x0000000C), helpstring("Set a meter to be active by name.\0le.\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x00000001), helpstring("Totals of all registers of all meters\0\0e Meter registers for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Totals([out, retval] VARIANT* Value);
    [propget, id(0x000000C9), helpstring("Array of doubles to set values of Peak Current property\0 for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Peakcurrent([out, retval] VARIANT* Value);
    [propput, id(0x000000C9), helpstring("Array of doubles to set values of Peak Current property\0 for the active Meter.\0ost recent solution.\0eue.\0y.\0g control actions.\0se properties.\0s collection or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Peakcurrent([in] VARIANT Value);
    [propget, id(0x000000CA), helpstring("Set the magnitude of the real part of the Calculated Current (normally determined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CalcCurrent([out, retval] VARIANT* Value);
    [propput, id(0x000000CA), helpstring("Set the magnitude of the real part of the Calculated Current (normally determined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CalcCurrent([in] VARIANT Value);
    [propget, id(0x000000CB), helpstring("Array of doubles: set the phase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllocFactors([out, retval] VARIANT* Value);
    [propput, id(0x000000CB), helpstring("Array of doubles: set the phase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllocFactors([in] VARIANT Value);
    [propget, id(0x000000CC), helpstring("Set Name of metered element\0ase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredElement([out, retval] BSTR* Value);
    [propput, id(0x000000CC), helpstring("Set Name of metered element\0ase allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredElement([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("set Number of Metered Terminal\0 allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredTerminal([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("set Number of Metered Terminal\0 allocation factors for the active meter.\0termined by solution) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MeteredTerminal([in] long Value);
    [propget, id(0x000000CE), helpstring("Global Flag in the DSS to indicate if Demand Interval (DI) files have been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DIFilesAreOpen([out, retval] VARIANT_BOOL* Value);
    [id(0x000000CF), helpstring("Causes all EnergyMeter objects to take a sample at the present time\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SampleAll(void);
    [id(0x000000D0), helpstring("Save All EnergyMeter objects\0s to take a sample at the present time\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SaveAll(void);
    [id(0x000000D1), helpstring("Open Demand Interval (DI) files\0o take a sample at the present time\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall OpenAllDIFiles(void);
    [id(0x000000D2), helpstring("Close All Demand Interval Files ( Necessary at the end of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CloseAllDIFiles(void);
    [propget, id(0x000000D3), helpstring("Number of zone end elements in the active meter zone.\0 of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CountEndElements([out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("Variant array of names of all zone end elements.\0one.\0 of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllEndElements([out, retval] VARIANT* Value);
    [propget, id(0x000000D5), helpstring("Number of Energy Meters in the Active Circuit\0s.\0one.\0 of a run)\0me\0e been properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000D6), helpstring("Wide string list of all branches in zone of the active energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllBranchesInZone([out, retval] VARIANT* Value);
    [propget, id(0x000000D7), helpstring("Number of branches in Active energymeter zone. (Same as sequencelist size)")]
    HRESULT _stdcall CountBranches([out, retval] long* Value);
    [propget, id(0x000000D8), helpstring("Returns SAIFI for this meter's Zone. Execute Reliability Calc method first.")]
    HRESULT _stdcall SAIFI([out, retval] double* Value);
    [propget, id(0x000000D9), helpstring("Get/set Index into Meter's SequenceList that contains branch pointers in lexical order. Earlier index guaranteed to be upline from later index. Sets PDelement active.")]
    HRESULT _stdcall SequenceIndex([out, retval] long* Value);
    [propput, id(0x000000D9), helpstring("Get/set Index into Meter's SequenceList that contains branch pointers in lexical order. Earlier index guaranteed to be upline from later index. Sets PDelement active.")]
    HRESULT _stdcall SequenceIndex([in] long Value);
    [propget, id(0x000000DA), helpstring("SAIFI based on kW rather than number of customers. Get after reliability calcs.")]
    HRESULT _stdcall SAIFIKW([out, retval] double* Value);
    [id(0x000000DB), helpstring("Calculate SAIFI, etc.")]
    HRESULT _stdcall DoReliabilityCalc([in] VARIANT_BOOL AssumeRestoration);
    [propget, id(0x000000DC), helpstring("Size of Sequence List")]
    HRESULT _stdcall SeqListSize([out, retval] long* Value);
    [propget, id(0x000000DD), helpstring("Total Number of customers in this zone (downline from the EnergyMeter)")]
    HRESULT _stdcall TotalCustomers([out, retval] long* Value);
    [propget, id(0x000000DE), helpstring("SAIDI for this meter's zone. Execute DoReliabilityCalc first.")]
    HRESULT _stdcall SAIDI([out, retval] double* Value);
    [propget, id(0x000000DF), helpstring("Total customer interruptions for this Meter zone based on reliability calcs.")]
    HRESULT _stdcall CustInterrupts([out, retval] double* Value);
    [propget, id(0x000000E0), helpstring("Number of feeder sections in this meter's zone")]
    HRESULT _stdcall NumSections([out, retval] long* Value);
    [id(0x000000E1), helpstring("Sets the designated section active if the index is valiid.")]
    HRESULT _stdcall SetActiveSection([in] long SectIdx);
    [propget, id(0x000000E2), helpstring("Type of OCP device. 1=Fuse; 2=Recloser; 3=Relay")]
    HRESULT _stdcall OCPDeviceType([out, retval] long* Value);
    [propget, id(0x000000E3), helpstring("Number of Customers in the active section.")]
    HRESULT _stdcall NumSectionCustomers([out, retval] long* Value);
    [propget, id(0x000000E4), helpstring("Number of branches (lines) in this section")]
    HRESULT _stdcall NumSectionBranches([out, retval] long* Value);
    [propget, id(0x000000E5), helpstring("Average Repair time in this section of the meter zone")]
    HRESULT _stdcall AvgRepairTime([out, retval] double* Value);
    [propget, id(0x000000E6), helpstring("Sum of Fault Rate time Repair Hrs in this section of the meter zone")]
    HRESULT _stdcall FaultRateXRepairHrs([out, retval] double* Value);
    [propget, id(0x000000E7), helpstring("Sum of the branch fault rates in this section of the meter's zone")]
    HRESULT _stdcall SumBranchFltRates([out, retval] double* Value);
    [propget, id(0x000000E8), helpstring("SequenceIndex of the branch at the head of this section")]
    HRESULT _stdcall SectSeqIdx([out, retval] long* Value);
    [propget, id(0x000000E9), helpstring("Total Customers downline from this section")]
    HRESULT _stdcall SectTotalCust([out, retval] long* Value);
  };

  [
    uuid(2D9B7548-D03E-478A-9FEA-9FC4033C793E),
    version(1.0),
    helpstring("Dispatch interface for Generators Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IGenerators: IDispatch
  {
    [propget, id(0x00000002), helpstring("Array of names of all Generator objects.\0zone.\0 active energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000003), helpstring("Array of Names of all generator energy meter registers\0energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterNames([out, retval] VARIANT* Value);
    [propget, id(0x00000004), helpstring("Array of valus in generator energy meter registers.\0rs\0energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall RegisterValues([out, retval] VARIANT* Value);
    [propget, id(0x00000005), helpstring("Sets first Generator to be active.  Returns 0 if none.\0energymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000006), helpstring("Sets next Generator to be active.  Returns 0 if no more.\0ergymeter object.\0properly opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x00000008), helpstring("Indicates whether the generator is forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForcedON([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000008), helpstring("Indicates whether the generator is forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForcedON([in] VARIANT_BOOL Value);
    [propget, id(0x00000009), helpstring("Sets a generator active by name.\0s forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x00000009), helpstring("Sets a generator active by name.\0s forced ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000C9), helpstring("Voltage base for the active generator, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000C9), helpstring("Voltage base for the active generator, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000CA), helpstring("kW output for the active generator. kvar is updated for current power factor.")]
    HRESULT _stdcall kW([out, retval] double* Value);
    [propput, id(0x000000CA), helpstring("kW output for the active generator. kvar is updated for current power factor")]
    HRESULT _stdcall kW([in] double Value);
    [propget, id(0x000000CB), helpstring("kvar output for the active generator. Updates power factor based on present kW value.")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000CB), helpstring("kvar output for the active generator. Updates power factor based on present kW.")]
    HRESULT _stdcall kvar([in] double Value);
    [propget, id(0x000000CC), helpstring("Power factor (pos. = producing vars). Updates kvar based on present kW value.")]
    HRESULT _stdcall PF([out, retval] double* Value);
    [propput, id(0x000000CC), helpstring("Power factor (pos. = producing vars). Updates kvar based on present kW value.")]
    HRESULT _stdcall PF([in] double Value);
    [propget, id(0x000000CD), helpstring("Number of phases\0. = producing vars)\0, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Number of phases\0. = producing vars)\0, kV\0ON regardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([in] long Value);
    [propget, id(0x000000CE), helpstring("Number of Generator Objects in Active Circuit\0egardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CF), helpstring("Get/Set active Generator by index into generators list.  1..Count")]
    HRESULT _stdcall idx([out, retval] long* Value);
    [propput, id(0x000000CF), helpstring("Get/Set active Generator by index into generators list. 1..Count")]
    HRESULT _stdcall idx([in] long Value);
    [propget, id(0x000000D0), helpstring("Generator Model")]
    HRESULT _stdcall Model([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Generator Model")]
    HRESULT _stdcall Model([in] long Value);
    [propget, id(0x000000D1), helpstring("kVA rating of the generator")]
    HRESULT _stdcall kVArated([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("KVA Rating of the generator")]
    HRESULT _stdcall kVArated([in] double Value);
    [propget, id(0x000000D2), helpstring("vmaxpu for Generator model")]
    HRESULT _stdcall Vmaxpu([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("Vmaxpu for generator model")]
    HRESULT _stdcall Vmaxpu([in] double Value);
    [propget, id(0x000000D3), helpstring("Vminpu for Generator model")]
    HRESULT _stdcall Vminpu([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Vminpu for Generator model")]
    HRESULT _stdcall Vminpu([in] double Value);
  };

  [
    uuid(315C0C38-929C-4942-BDF8-6DA12D001B47),
    version(1.0),
    helpstring("Dispatch interface for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IDSSProgress: IDispatch
  {
    [propput, id(0x00000001), helpstring("Percent progress to indicate [0..100]\0Circuit\0egardles of other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PctProgress([in] long Param1);
    [propput, id(0x00000002), helpstring("Caption to appear on the bottom of the DSS Progress form.\0other dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Caption([in] BSTR Param1);
    [id(0x00000003), helpstring("Shows progress form with null caption and progress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Show(void);
    [id(0x00000004), helpstring("Closes (hides) DSS Progress form.\0ion and progress set to zero.\0dispatch criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Close(void);
  };

  [
    uuid(4E3928A0-8B75-4127-885F-F4AD6B3F4323),
    version(1.0),
    helpstring("Dispatch interface for Settings Object\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ISettings: IDispatch
  {
    [propget, id(0x00000001), helpstring("{True | False*} Designates whether to allow duplicate names of objects\0h criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowDuplicates([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000001), helpstring("{True | False*} Designates whether to allow duplicate names of objects\0h criteria.\0 opened.\0n) for the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllowDuplicates([in] VARIANT_BOOL Value);
    [propget, id(0x00000002), helpstring("{True | False*}  Locks Zones on energy meters to prevent rebuilding if a circuit change occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZoneLock([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000002), helpstring("{True | False*}  Locks Zones on energy meters to prevent rebuilding if a circuit change occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ZoneLock([in] VARIANT_BOOL Value);
    [propput, id(0x00000003), helpstring("Sets all load allocation factors for all loads defined by XFKVA property to this value.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllocationFactors([in] double Param1);
    [propget, id(0x00000004), helpstring("List of Buses or (File=xxxx) syntax for the AutoAdd solution mode.\0perty to this value.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AutoBusList([out, retval] BSTR* Value);
    [propput, id(0x00000004), helpstring("List of Buses or (File=xxxx) syntax for the AutoAdd solution mode.\0perty to this value.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AutoBusList([in] BSTR Value);
    [propget, id(0x00000005), helpstring("{dssMultiphase * | dssPositiveSeq} IIndicate if the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CktModel([out, retval] long* Value);
    [propput, id(0x00000005), helpstring("{dssMultiphase * | dssPositiveSeq} IIndicate if the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CktModel([in] long Value);
    [propget, id(0x00000006), helpstring("Per Unit minimum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVminpu([out, retval] double* Value);
    [propput, id(0x00000006), helpstring("Per Unit minimum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVminpu([in] double Value);
    [propget, id(0x00000007), helpstring("Per Unit maximum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVmaxpu([out, retval] double* Value);
    [propput, id(0x00000007), helpstring("Per Unit maximum voltage for Normal conditions.\0the circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormVmaxpu([in] double Value);
    [propget, id(0x00000008), helpstring("Per Unit minimum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVminpu([out, retval] double* Value);
    [propput, id(0x00000008), helpstring("Per Unit minimum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVminpu([in] double Value);
    [propget, id(0x00000009), helpstring("Per Unit maximum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVmaxpu([out, retval] double* Value);
    [propput, id(0x00000009), helpstring("Per Unit maximum voltage for Emergency conditions.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergVmaxpu([in] double Value);
    [propget, id(0x0000000A), helpstring("Weighting factor applied to UE register values.\0s.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEweight([out, retval] double* Value);
    [propput, id(0x0000000A), helpstring("Weighting factor applied to UE register values.\0s.\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEweight([in] double Value);
    [propget, id(0x0000000B), helpstring("Weighting factor applied to Loss register values.\0\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossWeight([out, retval] double* Value);
    [propput, id(0x0000000B), helpstring("Weighting factor applied to Loss register values.\0\0 circuit model is positive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossWeight([in] double Value);
    [propget, id(0x0000000C), helpstring("Array of Integers defining energy meter registers to use for computing UE\0ive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEregs([out, retval] VARIANT* Value);
    [propput, id(0x0000000C), helpstring("Array of Integers defining energy meter registers to use for computing UE\0ive sequence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UEregs([in] VARIANT Value);
    [propget, id(0x0000000D), helpstring("Integer array defining which energy meter registers to use for computing losses\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossRegs([out, retval] VARIANT* Value);
    [propput, id(0x0000000D), helpstring("Integer array defining which energy meter registers to use for computing losses\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LossRegs([in] VARIANT Value);
    [propget, id(0x0000000E), helpstring("{True | False *} Gets value of trapezoidal integration flag in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Trapezoidal([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x0000000E), helpstring("{True | False *} Gets value of trapezoidal integration flag in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Trapezoidal([in] VARIANT_BOOL Value);
    [propget, id(0x0000000F), helpstring("Array of doubles defining the legal voltage bases in kV L-L\0in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageBases([out, retval] VARIANT* Value);
    [propput, id(0x0000000F), helpstring("Array of doubles defining the legal voltage bases in kV L-L\0in energy meters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageBases([in] VARIANT Value);
    [propget, id(0x00000010), helpstring("{True | False*} Denotes whether to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlTrace([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x00000010), helpstring("{True | False*} Denotes whether to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ControlTrace([in] VARIANT_BOOL Value);
    [propget, id(0x00000011), helpstring("Price Signal for the Circuit\0er to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceSignal([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Price Signal for the Circuit\0er to trace the control actions to a file.\0ters.\0s\0quence.\0occurs.\0or the Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceSignal([in] double Value);
    [propget, id(0x00000012), helpstring("Name of LoadShape object that serves as the source of price signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceCurve([out, retval] BSTR* Value);
    [propput, id(0x00000012), helpstring("Name of LoadShape object that serves as the source of price signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PriceCurve([in] BSTR Value);
  };

  [
    uuid(E1616BDB-589B-4E5D-A7CE-828ACD73E5D4),
    version(1.0),
    helpstring("Dispatch interface for Lines Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ILines: IDispatch
  {
    [propget, id(0x00000006), helpstring("Specify the name of the Line element to set it active.\0rice signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x00000006), helpstring("Specify the name of the Line element to set it active.\0rice signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x00000007), helpstring("Names of all Line Objects\0ne element to set it active.\0rice signal data for yearly simulations, etc.\0e Meter to force some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x00000008), helpstring("Invoking this property sets the first element active.  Returns 0 if no lines.  Otherwise, index of the line element.\0 some behavior on Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x00000009), helpstring("Invoking this property advances to the next Line element active.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [id(0x0000000A), helpstring("Creates a new Line and makes it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall New([in] BSTR Name, [out, retval] long* Value);
    [propget, id(0x0000000B), helpstring("Name of bus for terminal 1.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus1([out, retval] BSTR* Value);
    [propput, id(0x0000000B), helpstring("Name of bus for terminal 1.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus1([in] BSTR Value);
    [propget, id(0x0000000C), helpstring("Name of bus for terminal 2.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus2([out, retval] BSTR* Value);
    [propput, id(0x0000000C), helpstring("Name of bus for terminal 2.\0 it the Active Circuit Element.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Bus2([in] BSTR Value);
    [propget, id(0x0000000D), helpstring("Name of LineCode object that defines the impedances.\0ement.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LineCode([out, retval] BSTR* Value);
    [propput, id(0x0000000D), helpstring("Name of LineCode object that defines the impedances.\0ement.\0ive.  Returns 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall LineCode([in] BSTR Value);
    [propget, id(0x0000000E), helpstring("Length of line section in units compatible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Length([out, retval] double* Value);
    [propput, id(0x0000000E), helpstring("Length of line section in units compatible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Length([in] double Value);
    [propget, id(0x0000000F), helpstring("Number of Phases, this Line element.\0tible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([out, retval] long* Value);
    [propput, id(0x0000000F), helpstring("Number of Phases, this Line element.\0tible with the LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Phases([in] long Value);
    [propget, id(0x00000010), helpstring("Positive Sequence resistance, ohms per unit length.\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R1([out, retval] double* Value);
    [propput, id(0x00000010), helpstring("Positive Sequence resistance, ohms per unit length.\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R1([in] double Value);
    [propget, id(0x00000011), helpstring("Positive Sequence reactance, ohms per unit length.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X1([out, retval] double* Value);
    [propput, id(0x00000011), helpstring("Positive Sequence reactance, ohms per unit length.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X1([in] double Value);
    [propget, id(0x00000012), helpstring("Zero Sequence resistance, ohms per unit length.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R0([out, retval] double* Value);
    [propput, id(0x00000012), helpstring("Zero Sequence resistance, ohms per unit length.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R0([in] double Value);
    [propget, id(0x00000013), helpstring("Zero Sequence reactance ohms per unit length.\0.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X0([out, retval] double* Value);
    [propput, id(0x00000013), helpstring("Zero Sequence reactance ohms per unit length.\0.\0h.\0\0LineCode definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall X0([in] double Value);
    [propget, id(0x00000014), helpstring("Positive Sequence capacitance, nanofarads per unit length.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C1([out, retval] double* Value);
    [propput, id(0x00000014), helpstring("Positive Sequence capacitance, nanofarads per unit length.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C1([in] double Value);
    [propget, id(0x00000015), helpstring("Zero Sequence capacitance, nanofarads per unit length.\0th.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C0([out, retval] double* Value);
    [propput, id(0x00000015), helpstring("Zero Sequence capacitance, nanofarads per unit length.\0th.\0e definition.\0 0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall C0([in] double Value);
    [propget, id(0x00000016), helpstring("Resistance matrix (full), ohms per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rmatrix([out, retval] VARIANT* Value);
    [propput, id(0x00000016), helpstring("Resistance matrix (full), ohms per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rmatrix([in] VARIANT Value);
    [propget, id(0x00000017)]
    HRESULT _stdcall Xmatrix([out, retval] VARIANT* Value);
    [propput, id(0x00000017)]
    HRESULT _stdcall Xmatrix([in] VARIANT Value);
    [propget, id(0x00000018)]
    HRESULT _stdcall Cmatrix([out, retval] VARIANT* Value);
    [propput, id(0x00000018)]
    HRESULT _stdcall Cmatrix([in] VARIANT Value);
    [propget, id(0x00000019), helpstring("Normal ampere rating of Line.\0 per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormAmps([out, retval] double* Value);
    [propput, id(0x00000019), helpstring("Normal ampere rating of Line.\0 per unit length. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NormAmps([in] double Value);
    [propget, id(0x0000001A), helpstring("Emergency (maximum) ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergAmps([out, retval] double* Value);
    [propput, id(0x0000001A), helpstring("Emergency (maximum) ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall EmergAmps([in] double Value);
    [propget, id(0x00000001), helpstring("Line geometry code\0 ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Geometry([out, retval] BSTR* Value);
    [propput, id(0x00000001), helpstring("Line geometry code\0 ampere rating of Line.\0gth. Variant array of doubles.\0 if no more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Geometry([in] BSTR Value);
    [propget, id(0x00000002), helpstring("Earth return resistance value used to compute line impedances at power frequency\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rg([out, retval] double* Value);
    [propput, id(0x00000002), helpstring("Earth return resistance value used to compute line impedances at power frequency\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rg([in] double Value);
    [propget, id(0x00000003), helpstring("Earth return reactance value used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xg([out, retval] double* Value);
    [propput, id(0x00000003), helpstring("Earth return reactance value used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xg([in] double Value);
    [propget, id(0x00000004), helpstring("Earth Resistivity, m-ohms\0ue used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rho([out, retval] double* Value);
    [propput, id(0x00000004), helpstring("Earth Resistivity, m-ohms\0ue used to compute line impedances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rho([in] double Value);
    [propget, id(0x00000005), helpstring("Yprimitive: Does Nothing at present on Put; Dangerous\0dances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Yprim([out, retval] VARIANT* Value);
    [propput, id(0x00000005), helpstring("Yprimitive: Does Nothing at present on Put; Dangerous\0dances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Yprim([in] VARIANT Value);
    [propget, id(0x000000C9), helpstring("Number of customers on this line section.\0; Dangerous\0dances at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumCust([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Total Number of customers served from this line section.\0ces at power frequency\0\0 more lines.  Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TotalCust([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets Parent of the active Line to be the active line. Returns 0 if no parent or action fails.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Parent([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Number of Line objects in Active Circuit.\0ctive line. Returns 0 if no parent or action fails.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Line spacing code")]
    HRESULT _stdcall Spacing([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Line spacing code")]
    HRESULT _stdcall Spacing([in] BSTR Value);
    [propget, id(0x000000CE)]
    HRESULT _stdcall Units([out, retval] long* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall Units([in] long Value);
  };

  [
    uuid(55055001-5EEC-4667-9CCA-63F3A60F31F3),
    version(1.0),
    helpstring("Interface for CtrlQueue Object\0ject\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ICtrlQueue: IDispatch
  {
    [id(0x00000065), helpstring("Clear control queue\0ts in Active Circuit.\0ctive line. Returns 0 if no parent or action fails.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ClearQueue(void);
    [id(0x00000067), helpstring("Delete a control action from the DSS control queue by referencing the handle of the action\0s.\0 Otherwise, index of the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delete([in] long ActionHandle);
    [propget, id(0x00000068), helpstring("Number of Actions on the current actionlist (that have been popped off the control queue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumActions([out, retval] long* Value);
    [propput, id(0x00000066), helpstring("Set the active action by index\0t actionlist (that have been popped off the control queue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Action([in] long Param1);
    [propget, id(0x00000069), helpstring("Code for the active action. Long integer code to tell the control device what to do\0ueue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActionCode([out, retval] long* Value);
    [propget, id(0x0000006A), helpstring("Handle (User defined) to device that must act on the pending action.\0ice what to do\0ueue by CheckControlActions)\0f the line element.\0n Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DeviceHandle([out, retval] long* Value);
    [id(0x0000006B), helpstring("Push a control action onto the DSS control queue by time, action code, and device handle (user defined). Returns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Push([in] long Hour, [in] double Seconds, [in] long ActionCode, [in] long DeviceHandle, [out, retval] long* Value);
    [id(0x0000006C), helpstring("Show entire control queue in CSV format\0ol queue by time, action code, and device handle (user defined). Returns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Show(void);
    [id(0x0000006D), helpstring("Clear the Action list.\0ue in CSV format\0ol queue by time, action code, and device handle (user defined). Returns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ClearActions(void);
    [propget, id(0x0000006E), helpstring("Pops next action off the action list and makes it the active action. Returns zero if none.")]
    HRESULT _stdcall PopAction([out, retval] long* Value);
    [propget, id(0x000000C9), helpstring("Number of items on the OpenDSS control Queue")]
    HRESULT _stdcall QueueSize([out, retval] long* Value);
    [id(0x000000CA), helpstring("Do All Actions currently on the Control queue. Side effect: clears the queue")]
    HRESULT _stdcall DoAllQueue(void);
  };

  [
    uuid(9A3FFA05-5B82-488C-B08D-FCA2FDB23101),
    version(1.0),
    helpstring("Dispatch interface for Loads Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ILoads: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing all Load names\0he active action. Returns Number of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Set first Load element to be active; returns 0 if none.\0tive action. Returns Number of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets next Load element to be active; returns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Set active load by name.\0 be active; returns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CC), helpstring("Set active load by name.\0 be active; returns 0 of none else index of active load.\0r of actions remaining.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("Sets active load by index into load list. 1..Count")]
    HRESULT _stdcall Idx([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Sets active load by index into load list.  1..Count")]
    HRESULT _stdcall Idx([in] long Value);
    [propget, id(0x000000CE), helpstring("Set kW for active Load. Updates kvar based on present PF.")]
    HRESULT _stdcall kW([out, retval] double* Value);
    [propput, id(0x000000CE), helpstring("Set kW for active Load. Updates kvar based on present PF.")]
    HRESULT _stdcall kW([in] double Value);
    [propget, id(0x000000CF), helpstring("Set kV rating for active Load. For 2 or more phases set Line-Line kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Set kV rating for active Load. For 2 or more phases set Line-Line kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000D0), helpstring("Set kvar for active Load. Updates PF based in present kW.")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000D0), helpstring("Set kvar for active Load. Updates PF based on present kW.")]
    HRESULT _stdcall kvar([in] double Value);
    [propget, id(0x000000D1), helpstring("Set Power Factor for Active Load. Specify leading PF as negative. Updates kvar based on kW value")]
    HRESULT _stdcall PF([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Set Power Factor for Active Load. Specify leading PF as negative. Updates kvar based on present value of kW.")]
    HRESULT _stdcall PF([in] double Value);
    [propget, id(0x000000D2), helpstring("Number of Load objects in active circuit.\0leading PF as negative.\0kV. Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000D3), helpstring("Average percent of nominal load in Monte Carlo studies; only if no loadshape defined for this load.")]
    HRESULT _stdcall PctMean([out, retval] double* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall PctMean([in] double Value);
    [propget, id(0x000000D4), helpstring("Percent standard deviation for Monte Carlo load studies; if there is no loadshape assigned to this load.")]
    HRESULT _stdcall PctStdDev([out, retval] double* Value);
    [propput, id(0x000000D4)]
    HRESULT _stdcall PctStdDev([in] double Value);
    [propget, id(0x000000D5), helpstring("Factor for allocating loads by connected xfkva")]
    HRESULT _stdcall AllocationFactor([out, retval] double* Value);
    [propput, id(0x000000D5)]
    HRESULT _stdcall AllocationFactor([in] double Value);
    [propget, id(0x000000D6), helpstring("Factor relates average to peak kw.  Used for allocation with kwh and kwhdays/")]
    HRESULT _stdcall Cfactor([out, retval] double* Value);
    [propput, id(0x000000D6)]
    HRESULT _stdcall Cfactor([in] double Value);
    [propget, id(0x000000D7), helpstring("A code number used to separate loads by class or group. No effect on the solution.")]
    HRESULT _stdcall Class([out, retval] long* Value);
    [propput, id(0x000000D7)]
    HRESULT _stdcall Class([in] long Value);
    [propget, id(0x000000D8), helpstring("Delta loads are connected line-to-line.")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D8)]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000D9), helpstring("Name of a loadshape with both Mult and Qmult, for CVR factors as a function of time.")]
    HRESULT _stdcall CVRcurve([out, retval] BSTR* Value);
    [propput, id(0x000000D9)]
    HRESULT _stdcall CVRcurve([in] BSTR Value);
    [propget, id(0x000000DA), helpstring("Percent reduction in P for percent reduction in V. Must be used with dssLoadModelCVR.")]
    HRESULT _stdcall CVRwatts([out, retval] double* Value);
    [propput, id(0x000000DA)]
    HRESULT _stdcall CVRwatts([in] double Value);
    [propget, id(0x000000DB), helpstring("Percent reduction in Q for percent reduction in V. Must be used with dssLoadModelCVR.")]
    HRESULT _stdcall CVRvars([out, retval] double* Value);
    [propput, id(0x000000DB)]
    HRESULT _stdcall CVRvars([in] double Value);
    [propget, id(0x000000DC), helpstring("Name of the loadshape for a daily load profile.")]
    HRESULT _stdcall daily([out, retval] BSTR* Value);
    [propput, id(0x000000DC)]
    HRESULT _stdcall daily([in] BSTR Value);
    [propget, id(0x000000DD), helpstring("Name of the loadshape for a duty cycle simulation.")]
    HRESULT _stdcall duty([out, retval] BSTR* Value);
    [propput, id(0x000000DD)]
    HRESULT _stdcall duty([in] BSTR Value);
    [propget, id(0x000000DF), helpstring("Base load kva. Also defined kw and kvar or pf input, or load allocation by kwh or xfkva.")]
    HRESULT _stdcall kva([out, retval] double* Value);
    [propput, id(0x000000DF)]
    HRESULT _stdcall kva([in] double Value);
    [propget, id(0x000000E0), helpstring("kwh billed for this period. Can be used with Cfactor for load allocation.")]
    HRESULT _stdcall kwh([out, retval] double* Value);
    [propput, id(0x000000E0)]
    HRESULT _stdcall kwh([in] double Value);
    [propget, id(0x000000E1), helpstring("Length of kwh billing period for average demand calculation. Default 30.")]
    HRESULT _stdcall kwhdays([out, retval] double* Value);
    [propput, id(0x000000E1)]
    HRESULT _stdcall kwhdays([in] double Value);
    [propget, id(0x000000E2), helpstring("The Load Model defines variation of P and Q with voltage.")]
    HRESULT _stdcall Model([out, retval] enum LoadModels* Value);
    [propput, id(0x000000E2)]
    HRESULT _stdcall Model([in] enum LoadModels Value);
    [propget, id(0x000000E3), helpstring("Number of customers in this load, defaults to one.")]
    HRESULT _stdcall NumCust([out, retval] long* Value);
    [propput, id(0x000000E3)]
    HRESULT _stdcall NumCust([in] long Value);
    [propget, id(0x000000E4), helpstring("Neutral resistance for wye-connected loads.")]
    HRESULT _stdcall Rneut([out, retval] double* Value);
    [propput, id(0x000000E4)]
    HRESULT _stdcall Rneut([in] double Value);
    [propget, id(0x000000E5), helpstring("Name of harmonic current spectrrum shape.")]
    HRESULT _stdcall Spectrum([out, retval] BSTR* Value);
    [propput, id(0x000000E5)]
    HRESULT _stdcall Spectrum([in] BSTR Value);
    [propget, id(0x000000E6), helpstring("Maximum per-unit voltage to use the load model. Above this, constant Z applies.")]
    HRESULT _stdcall Vmaxpu([out, retval] double* Value);
    [propput, id(0x000000E6)]
    HRESULT _stdcall Vmaxpu([in] double Value);
    [propget, id(0x000000E7), helpstring("Minimum voltage for unserved energy (UE) evaluation.")]
    HRESULT _stdcall Vminemerg([out, retval] double* Value);
    [propput, id(0x000000E7)]
    HRESULT _stdcall Vminemerg([in] double Value);
    [propget, id(0x000000E8), helpstring("Minimum voltage for energy exceeding normal (EEN) evaluations.")]
    HRESULT _stdcall Vminnorm([out, retval] double* Value);
    [propput, id(0x000000E8)]
    HRESULT _stdcall Vminnorm([in] double Value);
    [propget, id(0x000000E9), helpstring("Minimum voltage to apply the load model. Below this, constant Z is used.")]
    HRESULT _stdcall Vminpu([out, retval] double* Value);
    [propput, id(0x000000E9)]
    HRESULT _stdcall Vminpu([in] double Value);
    [propget, id(0x000000EA), helpstring("Rated service transformer kVA for load allocation, using AllocationFactor. Affects kW, kvar, and pf.")]
    HRESULT _stdcall xfkVA([out, retval] double* Value);
    [propput, id(0x000000EA)]
    HRESULT _stdcall xfkVA([in] double Value);
    [propget, id(0x000000EB), helpstring("Neutral reactance for wye-connected loads.")]
    HRESULT _stdcall Xneut([out, retval] double* Value);
    [propput, id(0x000000EB)]
    HRESULT _stdcall Xneut([in] double Value);
    [propget, id(0x000000EC), helpstring("Name of yearly duration loadshape")]
    HRESULT _stdcall Yearly([out, retval] BSTR* Value);
    [propput, id(0x000000EC)]
    HRESULT _stdcall Yearly([in] BSTR Value);
    [propget, id(0x000000ED), helpstring("Response to load multipliers: Fixed (growth only), Exempt (no LD curve), Variable (all).")]
    HRESULT _stdcall Status([out, retval] enum LoadStatus* Value);
    [propput, id(0x000000ED)]
    HRESULT _stdcall Status([in] enum LoadStatus Value);
    [propget, id(0x000000DE), helpstring("Name of the growthshape curve for yearly load growth factors.")]
    HRESULT _stdcall Growth([out, retval] BSTR* Value);
    [propput, id(0x000000DE)]
    HRESULT _stdcall Growth([in] BSTR Value);
    [propget, id(0x000000EE), helpstring("Array of 7  doubles with values for ZIPV property of the LOAD object")]
    HRESULT _stdcall ZIPV([out, retval] VARIANT* Value);
    [propput, id(0x000000EE)]
    HRESULT _stdcall ZIPV([in] VARIANT Value);
    [propget, id(0x000000EF)]
    HRESULT _stdcall pctSeriesRL([out, retval] double* Value);
    [propput, id(0x000000EF), helpstring("Percent of Load that is modeled as series R-L for harmonics studies")]
    HRESULT _stdcall pctSeriesRL([in] double Value);
    [propget, id(0x000000F0), helpstring("Relative Weighting factor for the active LOAD")]
    HRESULT _stdcall RelWeight([out, retval] double* Value);
    [propput, id(0x000000F0), helpstring("Relative Weighting factor for the active LOAD")]
    void _stdcall RelWeight([in] double Value);
  };

  [
    uuid(C22D4922-6DC2-4283-93AB-4F2138C4B922),
    version(1.0),
    helpstring("Dispatch interface for DSSElement Object\0\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IDSSElement: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Full Name of Active DSS Object (general element or circuit element).\0 Else actual kV across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propget, id(0x000000CA), helpstring("Collection of properties for Active DSS object (general element or circuit element).\0across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Properties([in] VARIANT Indx, [out, retval] IDSSProperty** Value);
    [propget, id(0x000000CB), helpstring("Number of Properties for the active DSS object.\0general element or circuit element).\0across terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumProperties([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Variant array of strings containing the names of all properties for the active DSS object.\0 terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllPropertyNames([out, retval] VARIANT* Value);
  };

  [
    uuid(8E73B64C-0D99-4D19-AB90-170DBBD06FA0),
    version(1.0),
    helpstring("Dispatch interface for ActiveClass Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IActiveClass: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings consisting of all element names in the active class.\0 DSS object.\0 terminals.\0g.\0eturns Control Queue handle.\0Load Allocation\0ion or AllElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Sets first element in the active class to be the active DSS object. If object is a CktElement, ActiveCktELment also points to this element. Returns 0 if none.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets next element in active class to be the active DSS object. If object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Name of the Active Element of the Active Class")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CC)]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("Number of elements in this class. Same as Count property.\0ect. If object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumElements([out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Returns name of active class.\0ss. Same as Count property.\0ect. If object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ActiveClassName([out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Number of elements in Active Class. Same as NumElements Property.\0object is a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(3C171A69-40AB-46AA-B037-9C4EBB9FBFCD),
    version(1.0),
    helpstring("Dispatch interface for Capacitors\0 Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ICapacitors: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Bank kV rating. Use LL for 2 or 3 phases, or actual can rating for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000C9), helpstring("Bank kV rating. Use LL for 2 or 3 phases, or actual can rating for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000CA), helpstring("Total bank KVAR, distributed equally among phases and steps.\0g for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000CA), helpstring("Total bank KVAR, distributed equally among phases and steps.\0g for 1 phase.\0a CktElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kvar([in] double Value);
    [propget, id(0x000000CB), helpstring("Number of steps (default 1) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumSteps([out, retval] long* Value);
    [propput, id(0x000000CB), helpstring("Number of steps (default 1) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumSteps([in] long Value);
    [propget, id(0x000000CC), helpstring("Delta connection or wye?\x01) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CC), helpstring("Delta connection or wye?\x01) for distributing and switching the total bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000CD), helpstring("Variant array of strings with all Capacitor names in the circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("Sets the first Capacitor active. Returns 0 if no more.\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CF), helpstring("Sets the next Capacitor active. Returns 0 if no more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000D0), helpstring("Sets the acitve Capacitor by Name.\0urns 0 if no more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Sets the acitve Capacitor by Name.\0urns 0 if no more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Number of Capacitor objects in active circuit.\0 more.\0\0e circuit.\0al bank kVAR.\0tElement, ActiveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [id(0x000000D2), helpstring("Adds one step of the capacitor if available. If successful returns TRUE.")]
    HRESULT _stdcall AddStep([out, retval] VARIANT_BOOL* value);
    [id(0x000000D3), helpstring("Subtract one capacitor step.  Returns False if no more steps.")]
    HRESULT _stdcall SubtractStep([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000D4), helpstring("Number of Steps available in cap bank to be switched ON.")]
    HRESULT _stdcall AvailableSteps([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("A variant array of  integer [0..numsteps-1] indicating state of each step. If value is -1 an error has occurred.")]
    HRESULT _stdcall States([out, retval] VARIANT* Value);
    [propput, id(0x000000D5), helpstring("Variant array of integer [0 ..numSteps-1] indicating the state of each step")]
    HRESULT _stdcall States([in] VARIANT Value);
    [id(0x000000D6), helpstring("Open all steps, all phases of the Capacitor ")]
    HRESULT _stdcall Open(void);
    [id(0x000000D7), helpstring("Close all phases of all steps of the Capacitor")]
    HRESULT _stdcall Close(void);
  };

  [
    uuid(94E9CACF-A548-4DC2-B460-E2642B501387),
    version(1.0),
    helpstring("Dispatch interface for Transformers\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ITransformers: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of windings on this transformer. Allocates memory; set or change this property first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumWindings([out, retval] long* Value);
    [propput, id(0x000000C9), helpstring("Number of windings on this transformer. Allocates memory; set or change this property first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumWindings([in] long Value);
    [propget, id(0x000000CA), helpstring("Name of an XfrmCode that supplies electircal parameters for this Transformer.\0roperty first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall XfmrCode([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Name of an XfrmCode that supplies electircal parameters for this Transformer.\0roperty first.\0iveCktElement also points to this element.  Returns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall XfmrCode([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Active Winding Number from 1..NumWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Wdg([out, retval] long* Value);
    [propput, id(0x000000CB), helpstring("Active Winding Number from 1..NumWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Wdg([in] long Value);
    [propget, id(0x000000CC), helpstring("Active Winding resistance in %\0umWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R([out, retval] double* Value);
    [propput, id(0x000000CC), helpstring("Active Winding resistance in %\0umWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall R([in] double Value);
    [propget, id(0x000000CD), helpstring("Active Winding tap in per-unit.\0mWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tap([out, retval] double* Value);
    [propput, id(0x000000CD), helpstring("Active Winding tap in per-unit.\0mWindings. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Tap([in] double Value);
    [propget, id(0x000000CE), helpstring("Active Winding minimum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MinTap([out, retval] double* Value);
    [propput, id(0x000000CE), helpstring("Active Winding minimum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MinTap([in] double Value);
    [propget, id(0x000000CF), helpstring("Active Winding maximum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTap([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Active Winding maximum tap in per-unit.\0s. Update this before reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTap([in] double Value);
    [propget, id(0x000000D0), helpstring("Active Winding number of tap steps betwein MinTap and MaxTap.\0reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumTaps([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Active Winding number of tap steps betwein MinTap and MaxTap.\0reading or setting a sequence of winding properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall NumTaps([in] long Value);
    [propget, id(0x000000D1), helpstring("Active Winding kV rating.  Phase-phase for 2 or 3 phases, actual winding kV for 1 phase transformer.\0g properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Active Winding kV rating.  Phase-phase for 2 or 3 phases, actual winding kV for 1 phase transformer.\0g properties (R, Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kV([in] double Value);
    [propget, id(0x000000D2), helpstring("Active Winding kVA rating. On winding 1, this also determines normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kVA([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("Active Winding kVA rating. On winding 1, this also determines normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall kVA([in] double Value);
    [propget, id(0x000000D3), helpstring("Active Winding neutral reactance [ohms] for wye connections.\0 normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xneut([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Active Winding neutral reactance [ohms] for wye connections.\0 normal and emergency current ratings for all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xneut([in] double Value);
    [propget, id(0x000000D4), helpstring("Active Winding neutral resistance [ohms] for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rneut([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Active Winding neutral resistance [ohms] for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Rneut([in] double Value);
    [propget, id(0x000000D5), helpstring("Active Winding delta or wye connection?\0 for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D5), helpstring("Active Winding delta or wye connection?\0 for wye connections. Set less than zero for ungrounded wye.\0r all windings.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000D6), helpstring("Percent reactance between windings 1 and 2, on winding 1 kVA base. Use for 2-winding or 3-winding transformers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xhl([out, retval] double* Value);
    [propput, id(0x000000D6), helpstring("Percent reactance between windings 1 and 2, on winding 1 kVA base. Use for 2-winding or 3-winding transformers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xhl([in] double Value);
    [propget, id(0x000000D7), helpstring("Percent reactance between windigns 1 and 3, on winding 1 kVA base.  Use for 3-winding transformers only.\0rmers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xht([out, retval] double* Value);
    [propput, id(0x000000D7), helpstring("Percent reactance between windigns 1 and 3, on winding 1 kVA base.  Use for 3-winding transformers only.\0rmers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Xht([in] double Value);
    [propget, id(0x000000D8), helpstring("Percent reactance between windings 2 and 3, on winding 1 kVA base. Use for 3-winding transformers only.")]
    HRESULT _stdcall Xlt([out, retval] double* Value);
    [propput, id(0x000000D8), helpstring("Percent reactance between windings 2 and 3, on winding 1 kVA base. Use for 3-winding transformers only.")]
    HRESULT _stdcall Xlt([in] double Value);
    [propget, id(0x000000D9), helpstring("Sets a Transformer active by Name.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000D9), helpstring("Sets a Transformer active by Name.")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000DA), helpstring("Sets the first Transformer active. Returns 0 if no more.\0_ kVA base. Use for 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000DB), helpstring("Sets the next Transformer active. Returns 0 if no more.\0\0_ kVA base. Use for 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000DC), helpstring("Variant array of strings with all Transformer names in the active circuit.\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000DD)]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(112AB9E6-C112-46BE-A8A3-F72C5FA3A657),
    version(1.0),
    helpstring("Dispatch interface for SwtControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ISwtControls: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings with all SwtControl names in the active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Sets a SwtControl active by Name.\0SwtControl names in the active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Sets a SwtControl active by Name.\0SwtControl names in the active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Sets the first SwtControl active. Returns 0 if no more.\0e active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next SwtControl active. Returns 0 if no more.\0\0e active circuit.\0\0r 3-winding transformers only.\0mers.\0ngs.\0 Tap, kV, kVA, etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Open or Close the switch. No effect if switch is locked.  However, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Action([out, retval] enum ActionCodes* Value);
    [propput, id(0x000000CD), helpstring("Open or Close the switch. No effect if switch is locked.  However, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Action([in] enum ActionCodes Value);
    [propget, id(0x000000CE), helpstring("The lock prevents both manual and automatic switch operation.\0ver, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsLocked([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CE), helpstring("The lock prevents both manual and automatic switch operation.\0ver, Reset removes any lock and then closes the switch (shelf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsLocked([in] VARIANT_BOOL Value);
    [propget, id(0x000000CF), helpstring("Time delay [s] betwen arming and opening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Time delay [s] betwen arming and opening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([in] double Value);
    [propget, id(0x000000D0), helpstring("Full name of the switched element.\0ening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedObj([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Full name of the switched element.\0ening or closing the switch.  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedObj([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Terminal number where the switch is located on the SwitchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedTerm([out, retval] long* Value);
    [propput, id(0x000000D1), helpstring("Terminal number where the switch is located on the SwitchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall SwitchedTerm([in] long Value);
    [propget, id(0x000000D2)]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(4C132096-4161-4D9B-A701-E6CCCFF1D5AE),
    version(1.0),
    helpstring("Dispatch interface for CapControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ICapControls: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings with all CapControl names.\0witchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Sets a CapControl active by name.\0CapControl names.\0witchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Sets a CapControl active by name.\0CapControl names.\0witchedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Sets the first CapControl as active. Return 0 if none.\0chedObj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Gets the next CapControl in the circut. Returns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Type of automatic controller.\0e circut. Returns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([out, retval] enum CapControlModes* Value);
    [propput, id(0x000000CD), helpstring("Type of automatic controller.\0e circut. Returns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Mode([in] enum CapControlModes Value);
    [propget, id(0x000000CE), helpstring("Name of the Capacitor that is controlled.\0turns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capacitor([out, retval] BSTR* Value);
    [propput, id(0x000000CE), helpstring("Name of the Capacitor that is controlled.\0turns 0 if none.\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Capacitor([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Full name of the element that PT and CT are connected to.\0\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredObj([out, retval] BSTR* Value);
    [propput, id(0x000000CF), helpstring("Full name of the element that PT and CT are connected to.\0\0Obj\0  Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredObj([in] BSTR Value);
    [propget, id(0x000000D0), helpstring("Terminal number on the element that PT and CT are connected to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredTerm([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Terminal number on the element that PT and CT are connected to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredTerm([in] long Value);
    [propget, id(0x000000D1), helpstring("Transducer ratio from pirmary current to control current.\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTratio([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Transducer ratio from pirmary current to control current.\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTratio([in] double Value);
    [propget, id(0x000000D2), helpstring("Transducer ratio from primary feeder to control voltage.\0\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("Transducer ratio from primary feeder to control voltage.\0\0d to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([in] double Value);
    [propget, id(0x000000D3), helpstring("Threshold to arm or switch on a step.  See Mode for units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ONSetting([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Threshold to arm or switch on a step.  See Mode for units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ONSetting([in] double Value);
    [propget, id(0x000000D4), helpstring("Threshold to switch off a step. See Mode for units.\0units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall OFFSetting([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Threshold to switch off a step. See Mode for units.\0units.\0 to.\0 Control may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall OFFSetting([in] double Value);
    [propget, id(0x000000D5), helpstring("With VoltOverride, swtich off whenever PT voltage exceeds this level.\0ol may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmax([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("With VoltOverride, swtich off whenever PT voltage exceeds this level.\0ol may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmax([in] double Value);
    [propget, id(0x000000D6), helpstring("With VoltOverride, switch ON whenever PT voltage drops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmin([out, retval] double* Value);
    [propput, id(0x000000D6), helpstring("With VoltOverride, switch ON whenever PT voltage drops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Vmin([in] double Value);
    [propget, id(0x000000D7), helpstring("Enables Vmin and Vmax to override the control Mode\0ops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UseVoltOverride([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D7), helpstring("Enables Vmin and Vmax to override the control Mode\0ops below this level.\0may reset before actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall UseVoltOverride([in] VARIANT_BOOL Value);
    [propget, id(0x000000D8), helpstring("Time delay [s] to switch on after arming.  Control may reset before actually switching.\0e actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000D8), helpstring("Time delay [s] to switch on after arming.  Control may reset before actually switching.\0e actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([in] double Value);
    [propget, id(0x000000D9), helpstring("Time delay [s] before swithcing off a step. Control may reset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DelayOff([out, retval] double* Value);
    [propput, id(0x000000D9), helpstring("Time delay [s] before swithcing off a step. Control may reset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall DelayOff([in] double Value);
    [propget, id(0x000000DA)]
    HRESULT _stdcall DeadTime([out, retval] double* Value);
    [propput, id(0x000000DA)]
    HRESULT _stdcall DeadTime([in] double Value);
    [propget, id(0x000000DB), helpstring("Number of CapControls in Active Circuit\0ep. Control may reset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
  };

  [
    uuid(3F983AD2-B658-4CE8-B4C1-DE0A9EDD47FD),
    version(1.0),
    helpstring("Dispatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IRegControls: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing all RegControl names\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Get/set Active RegControl  name")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CA), helpstring("Sets a RegControl active by name\0ng all RegControl names\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CB), helpstring("Sets the first RegControl active. Returns 0 if none.\0mes\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next RegControl active. Returns 0 if none.\0\0mes\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Name of a remote regulated bus, in lieu of LDC settings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredBus([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Name of a remote regulated bus, in lieu of LDC settings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MonitoredBus([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Name of the transformer this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Transformer([out, retval] BSTR* Value);
    [propput, id(0x000000CE), helpstring("Name of the transformer this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Transformer([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Tapped winding number\0r this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapWinding([out, retval] long* Value);
    [propput, id(0x000000CF), helpstring("Tapped winding number\0r this regulator controls\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapWinding([in] long Value);
    [propget, id(0x000000D0), helpstring("Winding number for PT and CT connections\0ntrols\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Winding([out, retval] long* Value);
    [propput, id(0x000000D0), helpstring("Winding number for PT and CT connections\0ntrols\0ettings\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Winding([in] long Value);
    [propget, id(0x000000D1), helpstring("CT primary ampere rating (secondary is 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTPrimary([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("CT primary ampere rating (secondary is 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall CTPrimary([in] double Value);
    [propget, id(0x000000D2), helpstring("PT ratio for voltage control settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("PT ratio for voltage control settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall PTratio([in] double Value);
    [propget, id(0x000000D3), helpstring("LDC R setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardR([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("LDC R setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardR([in] double Value);
    [propget, id(0x000000D4), helpstring("LDC X setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardX([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("LDC X setting in Volts\0ntrol settings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardX([in] double Value);
    [propget, id(0x000000D5), helpstring("Reverse LDC R setting in Volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseR([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Reverse LDC R setting in Volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseR([in] double Value);
    [propget, id(0x000000D6), helpstring("Reverse LDC X setting in volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseX([out, retval] double* Value);
    [propput, id(0x000000D6), helpstring("Reverse LDC X setting in volts.\0tings\0 0.2 amperes)\0ngs\0\0eset before actually switching.\0 actually operating the switch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseX([in] double Value);
    [propget, id(0x000000D7), helpstring("Regulator can use different settings in the reverse direction.  Usually not applicable to substation transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsReversible([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D7), helpstring("Regulator can use different settings in the reverse direction.  Usually not applicable to substation transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsReversible([in] VARIANT_BOOL Value);
    [propget, id(0x000000D8), helpstring("Time delay is inversely adjsuted, proportinal to the amount of voltage outside the regulating band.\0 transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsInverseTime([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D8), helpstring("Time delay is inversely adjsuted, proportinal to the amount of voltage outside the regulating band.\0 transformers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall IsInverseTime([in] VARIANT_BOOL Value);
    [propget, id(0x000000D9), helpstring("Time delay [s] after arming before the first tap change. Control may reset before actually changing taps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000D9), helpstring("Time delay [s] after arming before the first tap change. Control may reset before actually changing taps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Delay([in] double Value);
    [propget, id(0x000000DA), helpstring("Time delay [s] for subsequent tap changes in a set. Control may reset before actually changing taps.\0aps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapDelay([out, retval] double* Value);
    [propput, id(0x000000DA), helpstring("Time delay [s] for subsequent tap changes in a set. Control may reset before actually changing taps.\0aps.\0formers.\0itch.\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall TapDelay([in] double Value);
    [propget, id(0x000000DB), helpstring("Maximum tap change per iteration in STATIC solution mode. 1 is more realistic, 16 is the default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTapChange([out, retval] long* Value);
    [propput, id(0x000000DB), helpstring("Maximum tap change per iteration in STATIC solution mode. 1 is more realistic, 16 is the default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall MaxTapChange([in] long Value);
    [propget, id(0x000000DC), helpstring("First house voltage limit on PT secondary base.  Setting to 0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageLimit([out, retval] double* Value);
    [propput, id(0x000000DC), helpstring("First house voltage limit on PT secondary base.  Setting to 0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall VoltageLimit([in] double Value);
    [propget, id(0x000000DD), helpstring("Regulation bandwidth in forward direciton, centered on Vreg\0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardBand([out, retval] double* Value);
    [propput, id(0x000000DD), helpstring("Regulation bandwidth in forward direciton, centered on Vreg\0 disables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardBand([in] double Value);
    [propget, id(0x000000DE), helpstring("Target voltage in the forward direction, on PT secondary base.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardVreg([out, retval] double* Value);
    [propput, id(0x000000DE), helpstring("Target voltage in the forward direction, on PT secondary base.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ForwardVreg([in] double Value);
    [propget, id(0x000000DF), helpstring("Bandwidth in reverse direction, centered on reverse Vreg.\0ase.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseBand([out, retval] double* Value);
    [propput, id(0x000000DF), helpstring("Bandwidth in reverse direction, centered on reverse Vreg.\0ase.\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseBand([in] double Value);
    [propget, id(0x000000E0), helpstring("Target voltage in the revese direction, on PT secondary base.\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseVreg([out, retval] double* Value);
    [propput, id(0x000000E0), helpstring("Target voltage in the revese direction, on PT secondary base.\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall ReverseVreg([in] double Value);
    [propget, id(0x000000E1), helpstring("Number of RegControl objects in Active Circuit\0econdary base.\0\0isables this function.\0he default for a faster soluiton.\0\0lf state).\0etc.)\0eturns 0 if no more.\0llElementNames.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000E2)]
    HRESULT _stdcall TapNumber([out, retval] long* Value);
    [propput, id(0x000000E2), helpstring("Integer number of the tap that the controlled transformer winding is currentliy on.")]
    HRESULT _stdcall TapNumber([in] long Value);
  };

  [
    uuid(03FADB98-4F30-416E-ACD2-9BD987A0CBC3),
    version(1.0),
    helpstring("Dispatch interface for Topology Object\0\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface ITopology: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of loops\0raphProperties; Do GetGraphProperties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall NumLoops([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Number of isolated branches (PD elements and capacitors).")]
    HRESULT _stdcall NumIsolatedBranches([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Variant array of all looped element names, by pairs.")]
    HRESULT _stdcall AllLoopedPairs([out, retval] VARIANT* Value);
    [propget, id(0x000000CC), helpstring("Variant array of all isolated branch names.")]
    HRESULT _stdcall AllIsolatedBranches([out, retval] VARIANT* Value);
    [propget, id(0x000000CD), helpstring("Number of isolated loads")]
    HRESULT _stdcall NumIsolatedLoads([out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Variant array of all isolated load names.")]
    HRESULT _stdcall AllIsolatedLoads([out, retval] VARIANT* Value);
    [propget, id(0x000000CF), helpstring("Name of the active branch.")]
    HRESULT _stdcall BranchName([out, retval] BSTR* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall BranchName([in] BSTR Value);
    [propget, id(0x000000D0), helpstring("Sets the first branch active, returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000D1), helpstring("Sets the next branch active, returns 0 if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000D2), helpstring("Returns index of the active branch")]
    HRESULT _stdcall ActiveBranch([out, retval] long* Value);
    [propget, id(0x000000D3), helpstring("Move forward in the tree, return index of new active branch or 0 if no more")]
    HRESULT _stdcall ForwardBranch([out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("MOve back toward the source, return index of new active branch, or 0 if no more.")]
    HRESULT _stdcall BackwardBranch([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("Move to looped branch, return index or 0 if none.")]
    HRESULT _stdcall LoopedBranch([out, retval] long* Value);
    [propget, id(0x000000D6), helpstring("Move to directly parallel branch, return index or 0 if none.")]
    HRESULT _stdcall ParallelBranch([out, retval] long* Value);
    [propget, id(0x000000D7), helpstring("First load at the active branch, return index or 0 if none.")]
    HRESULT _stdcall FirstLoad([out, retval] long* Value);
    [propget, id(0x000000D9), helpstring("Next load at the active branch, return index or 0 if no more.")]
    HRESULT _stdcall NextLoad([out, retval] long* Value);
    [propget, id(0x000000D8), helpstring("Topological depth of the active branch")]
    HRESULT _stdcall ActiveLevel([out, retval] long* Value);
    [propget, id(0x000000DA)]
    HRESULT _stdcall BusName([out, retval] BSTR* Value);
    [propput, id(0x000000DA), helpstring("Set the active branch to one containing this bus, return index or 0 if not found")]
    HRESULT _stdcall BusName([in] BSTR Value);
  };

  [
    uuid(DD7B80E9-5EFB-4E79-96CA-9C88F5A8A11C),
    version(1.0),
    helpstring("Dispatch interface for DSS_Executive Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
    dual,
    oleautomation
  ]
  interface IDSS_Executive: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of DSS Executive Commands\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall NumCommands([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Number of DSS Executive Options\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall NumOptions([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Get i-th command\0cutive Options\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall Command([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CC), helpstring("Get i-th option\0\0cutive Options\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall Option([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CD), helpstring("Get help string for i-th command\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall CommandHelp([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CE), helpstring("Get help string for i-th option\0\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall OptionHelp([in] long i, [out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Get present value of i-th option\0ment names.\0operties first to initialize values. GridStyle = [1..8] = [none, points, vertical lines, horiz lines, Lines, horiz dotlines, vert dotlines, dotlines].")]
    HRESULT _stdcall OptionValue([in] long i, [out, retval] BSTR* Value);
  };

  [
    uuid(3F5A5530-4E67-44BF-AE6D-561584C6BF47),
    helpstring("Dispatch interface for DSSEvents Object"),
    dual,
    oleautomation
  ]
  interface IDSSEvents: IDispatch
  {
  };

  [
    uuid(E7444ECD-B491-4D8E-A1E3-E5804BD571E2),
    helpstring("Dispatch interface for Sensors Object"),
    dual,
    oleautomation
  ]
  interface ISensors: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Name of the active sensor.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000C9), helpstring("Set the active Sensor by name.")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CA), helpstring("Number of Sensors in Active Circuit.")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets the first sensor active. Returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next Sensor active. Returns 0 if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Variant array of Sensor names.")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("True if measured voltages are line-line. Currents are always line currents.")]
    HRESULT _stdcall IsDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall IsDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000CF), helpstring("True if voltage measurements are 1-3, 3-2, 2-1.")]
    HRESULT _stdcall ReverseDelta([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall ReverseDelta([in] VARIANT_BOOL Value);
    [propget, id(0x000000D0), helpstring("Assumed percent error in the Sensor measurement. Default is 1.")]
    HRESULT _stdcall PctError([out, retval] double* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall PctError([in] double Value);
    [propget, id(0x000000D1), helpstring("Weighting factor for this Sensor measurement with respect to other Sensors. Default is 1.")]
    HRESULT _stdcall Weight([out, retval] double* Value);
    [propput, id(0x000000D1)]
    HRESULT _stdcall Weight([in] double Value);
    [propget, id(0x000000D2), helpstring("Full Name of the measured element")]
    HRESULT _stdcall MeteredElement([out, retval] BSTR* Value);
    [propput, id(0x000000D2)]
    HRESULT _stdcall MeteredElement([in] BSTR Value);
    [propget, id(0x000000D3), helpstring("Number of the measured terminal in the measured element.")]
    HRESULT _stdcall MeteredTerminal([out, retval] long* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall MeteredTerminal([in] long Value);
    [id(0x000000D4), helpstring("Clear the active Sensor.")]
    HRESULT _stdcall Reset(void);
    [id(0x000000D5), helpstring("Clear all Sensors in the Active Circuit.")]
    HRESULT _stdcall ResetAll(void);
    [propget, id(0x000000D6), helpstring("Voltage base for the sensor measurements. LL for 2 and 3-phase sensors, LN for 1-phase sensors.")]
    HRESULT _stdcall kVbase([out, retval] double* Value);
    [propput, id(0x000000D6)]
    HRESULT _stdcall kVbase([in] double Value);
    [propget, id(0x000000D7), helpstring("Array of doubles for the line current measurements; don't use with kWS and kVARS.")]
    HRESULT _stdcall Currents([out, retval] VARIANT* Value);
    [propput, id(0x000000D7)]
    HRESULT _stdcall Currents([in] VARIANT Value);
    [propget, id(0x000000D8), helpstring("Array of doubles for the LL or LN (depending on Delta connection) voltage measurements.")]
    HRESULT _stdcall kVS([out, retval] VARIANT* Value);
    [propput, id(0x000000D8)]
    HRESULT _stdcall kVS([in] VARIANT Value);
    [propget, id(0x000000D9), helpstring("Array of doubles for Q measurements. Overwrites Currents with a new estimate using kWS.")]
    HRESULT _stdcall kVARS([out, retval] VARIANT* Value);
    [propput, id(0x000000D9)]
    HRESULT _stdcall kVARS([in] VARIANT Value);
    [propget, id(0x000000DA), helpstring("Array of doubles for P measurements. Overwrites Currents with a new estimate using kVARS.")]
    HRESULT _stdcall kWS([out, retval] VARIANT* Value);
    [propput, id(0x000000DA)]
    HRESULT _stdcall kWS([in] VARIANT Value);
  };

  [
    uuid(97AA7680-E994-4A0C-BAC3-9B67BA49825C),
    helpstring("Dispatch interface for XYCurves Object"),
    dual,
    oleautomation
  ]
  interface IXYCurves: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of XYCurve Objects")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Sets first XYcurve object active; returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Advances to next XYCurve object; returns 0 if no more objects of this class")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Name of active XYCurve Object")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CC), helpstring("Get Name of active XYCurve Object")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CD), helpstring("Get/Set Number of points in X-Y curve")]
    HRESULT _stdcall Npts([out, retval] long* Value);
    [propput, id(0x000000CD), helpstring("Get/Set Number of Points in X-Y curve")]
    HRESULT _stdcall Npts([in] long Value);
    [propget, id(0x000000CE), helpstring("Get/Set X values as a Variant array of doubles. Set Npts to max number expected if setting")]
    HRESULT _stdcall Xarray([out, retval] VARIANT* Value);
    [propput, id(0x000000CE), helpstring("Get/Set X values as a Variant array of doubles. Set Npts to max number expected if setting")]
    HRESULT _stdcall Xarray([in] VARIANT Value);
    [propget, id(0x000000CF), helpstring("Get/Set Y values in curve; Set Npts to max number expected if setting")]
    HRESULT _stdcall Yarray([out, retval] VARIANT* Value);
    [propput, id(0x000000CF), helpstring("Get/Set Y values in curve; Set Npts to max number expected if setting")]
    void _stdcall Yarray([in] VARIANT Value);
    [propget, id(0x000000D0), helpstring("Set X value or get interpolated value after setting Y")]
    HRESULT _stdcall x([out, retval] double* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall x([in] double Value);
    [propget, id(0x000000D1), helpstring("Y value for present X or set this value then get corresponding X")]
    HRESULT _stdcall y([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Set Y value or get interpolated Y value after setting X")]
    HRESULT _stdcall y([in] double Value);
    [propget, id(0x000000D2), helpstring("Amount to shift X value from original curve")]
    HRESULT _stdcall Xshift([out, retval] double* Value);
    [propput, id(0x000000D2)]
    HRESULT _stdcall Xshift([in] double Value);
    [propget, id(0x000000D3), helpstring("amount to shift Y valiue from original curve")]
    HRESULT _stdcall Yshift([out, retval] double* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall Yshift([in] double Value);
    [propget, id(0x000000D4), helpstring("Factor to scale X values from original curve")]
    HRESULT _stdcall Xscale([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Factor to scale X values from original curve")]
    HRESULT _stdcall Xscale([in] double Value);
    [propget, id(0x000000D5), helpstring("Factor to scale Y values from original curve")]
    HRESULT _stdcall Yscale([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Amount to scale Y values from original curve. Represents a curve shift.")]
    HRESULT _stdcall Yscale([in] double Value);
  };

  [
    uuid(05D4E15E-1588-4ABB-8339-3527420C668B),
    helpstring("Dispatch interface for PDElements Object"),
    dual,
    oleautomation
  ]
  interface IPDElements: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Number of PD elements (including disabled elements)")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CA), helpstring("Set the first enabled PD element to be the active element.  Returns 0 if none found.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Advance to the next PD element in the circuit. Enabled elements only. Returns 0 when no more elements.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Variant boolean indicating of PD element should be treated as a shunt element rather than a series element. Applies to Capacitor and Reactor elements in particular.")]
    HRESULT _stdcall IsShunt([out, retval] VARIANT_BOOL* Value);
    [propget, id(0x000000CD), helpstring("Get/Set Number of failures per year. For LINE elements: Number of failures per unit length per year. ")]
    HRESULT _stdcall FaultRate([out, retval] double* Value);
    [propput, id(0x000000CD)]
    HRESULT _stdcall FaultRate([in] double Value);
    [propget, id(0x000000CE), helpstring("Get/Set percent of faults that are permanent (require repair). Otherwise, fault is assumed to be transient/temporary.")]
    HRESULT _stdcall pctPermanent([out, retval] double* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall pctPermanent([in] double Value);
    [propget, id(0x000000CF), helpstring("Get/Set name of active PD Element. Returns null string if active element is not PDElement type.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000D0), helpstring("Failure rate for this branch. Faults per year including length of line.")]
    HRESULT _stdcall Lambda([out, retval] double* Value);
    [propget, id(0x000000D1), helpstring("accummulated failure rate for this branch on downline")]
    HRESULT _stdcall AccumulatedL([out, retval] double* Value);
    [propget, id(0x000000D3), helpstring("Number of customers, this branch")]
    HRESULT _stdcall Numcustomers([out, retval] long* Value);
    [propget, id(0x000000D4), helpstring("Total number of customers from this branch to the end of the zone")]
    HRESULT _stdcall Totalcustomers([out, retval] long* Value);
    [propget, id(0x000000D5), helpstring("Sets the parent PD element to be the active circuit element.  Returns 0 if no more elements upline.")]
    HRESULT _stdcall ParentPDElement([out, retval] long* Value);
    [propget, id(0x000000D6), helpstring("Number of the terminal of active PD element that is on the \"from\" side. This is set after the meter zone is determined.")]
    HRESULT _stdcall FromTerminal([out, retval] long* Value);
    [propget, id(0x000000D7), helpstring("Total miles of line from this element to the end of the zone. For recloser siting algorithm.")]
    HRESULT _stdcall TotalMiles([out, retval] double* Value);
    [propget, id(0x000000D8), helpstring("Integer ID of the feeder section that this PDElement branch is part of")]
    HRESULT _stdcall SectionID([out, retval] long* Value);
    [propget, id(0x000000D2), helpstring("Average repair time for this element in hours")]
    HRESULT _stdcall RepairTime([out, retval] double* Value);
    [propput, id(0x000000D2), helpstring("Average repair time for this element in hours")]
    HRESULT _stdcall RepairTime([in] double Value);
  };

  [
    uuid(21001789-9F46-4323-93B0-8B31395FD6E4),
    helpstring("Dispatch interface for Reclosers Object"),
    dual,
    oleautomation
  ]
  interface IReclosers: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings with names of all Reclosers in Active Circuit")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Number of Reclosers in active circuit.")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Set First Recloser to be Active Ckt Element. Returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Iterate to the next recloser in the circuit. Returns zero if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Get Name of active Recloser or set the active Recloser by name.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CD)]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Full name of object this Recloser is monitoring.")]
    HRESULT _stdcall MonitoredObj([out, retval] BSTR* Value);
    [propput, id(0x000000CE), helpstring("Set monitored object by full name.")]
    HRESULT _stdcall MonitoredObj([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Terminal number of Monitored object for the Recloser ")]
    HRESULT _stdcall MonitoredTerm([out, retval] long* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall MonitoredTerm([in] long Value);
    [propget, id(0x000000D0), helpstring("Full name of the circuit element that is being switched by the Recloser.")]
    HRESULT _stdcall SwitchedObj([out, retval] BSTR* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall SwitchedObj([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Terminal number of the controlled device being switched by the Recloser")]
    HRESULT _stdcall SwitchedTerm([out, retval] long* Value);
    [propput, id(0x000000D1)]
    HRESULT _stdcall SwitchedTerm([in] long Value);
    [propget, id(0x000000D2), helpstring("Number of fast shots")]
    HRESULT _stdcall NumFast([out, retval] long* Value);
    [propput, id(0x000000D2)]
    HRESULT _stdcall NumFast([in] long Value);
    [propget, id(0x000000D3), helpstring("Number of shots to lockout (fast + delayed)")]
    HRESULT _stdcall Shots([out, retval] long* Value);
    [propput, id(0x000000D3)]
    HRESULT _stdcall Shots([in] long Value);
    [propget, id(0x000000D4), helpstring("Variant Array of Doubles: reclose intervals, s, between shots.")]
    HRESULT _stdcall RecloseIntervals([out, retval] VARIANT* Value);
    [propget, id(0x000000D5), helpstring("Phase trip curve multiplier or actual amps")]
    HRESULT _stdcall PhaseTrip([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Phase Trip multiplier or actual amps")]
    HRESULT _stdcall PhaseTrip([in] double Value);
    [propget, id(0x000000D6), helpstring("Phase instantaneous curve multipler or actual amps")]
    HRESULT _stdcall PhaseInst([out, retval] double* Value);
    [propput, id(0x000000D6)]
    HRESULT _stdcall PhaseInst([in] double Value);
    [propget, id(0x000000D7), helpstring("Ground (3I0) trip multiplier or actual amps")]
    HRESULT _stdcall GroundTrip([out, retval] double* Value);
    [propput, id(0x000000D7)]
    HRESULT _stdcall GroundTrip([in] double Value);
    [propget, id(0x000000D8), helpstring("Ground (3I0) instantaneous trip setting - curve multipler or actual amps.")]
    HRESULT _stdcall GroundInst([out, retval] double* Value);
    [propput, id(0x000000D8), helpstring("Ground (3I0) trip instantaneous multiplier or actual amps")]
    HRESULT _stdcall GroundInst([in] double Value);
    [id(0x000000D9), helpstring("Open recloser's controlled element and lock out the recloser")]
    HRESULT _stdcall Open(void);
    [id(0x000000DA), helpstring("Close the switched object controlled by the recloser. Resets recloser to first operation.")]
    HRESULT _stdcall Close(void);
    [propget, id(0x000000DB), helpstring("Get/Set the active Recloser by index into the recloser list.  1..Count")]
    HRESULT _stdcall idx([out, retval] long* Value);
    [propput, id(0x000000DB), helpstring("Get/Set the Active Recloser by index into the recloser list. 1..Count")]
    HRESULT _stdcall idx([in] long Value);
  };

  [
    uuid(76956697-6055-4E8E-B4D6-650805D3F90D),
    helpstring("Dispatch interface for Relays Object"),
    dual,
    oleautomation
  ]
  interface IRelays: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing names of all Relay elements")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Number of Relays in circuit")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Set First Relay active. If none, returns 0.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Advance to next Relay object. Returns 0 when no more relays.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Get name of active relay.")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Set Relay active by name")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Full name of object this Relay is monitoring.")]
    HRESULT _stdcall MonitoredObj([out, retval] BSTR* Value);
    [propput, id(0x000000CE)]
    HRESULT _stdcall MonitoredObj([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Number of terminal of monitored element that this Relay is monitoring.")]
    HRESULT _stdcall MonitoredTerm([out, retval] long* Value);
    [propput, id(0x000000CF)]
    HRESULT _stdcall MonitoredTerm([in] long Value);
    [propget, id(0x000000D0), helpstring("Full name of element that will be switched when relay trips.")]
    HRESULT _stdcall SwitchedObj([out, retval] BSTR* Value);
    [propput, id(0x000000D0)]
    HRESULT _stdcall SwitchedObj([in] BSTR Value);
    [propget, id(0x000000D1)]
    HRESULT _stdcall SwitchedTerm([out, retval] long* Value);
    [propput, id(0x000000D1), helpstring("Terminal number of the switched object that will be opened when the relay trips.")]
    HRESULT _stdcall SwitchedTerm([in] long Value);
    [propget, id(0x000000D2), helpstring("Get/Set active Relay by index into the Relay list. 1..Count")]
    HRESULT _stdcall idx([out, retval] long* Value);
    [propput, id(0x000000D2), helpstring("Get/Set Relay active by index into relay list. 1..Count")]
    HRESULT _stdcall idx([in] long Value);
  };

  [
    uuid(2B649EC0-FA89-45ED-A937-E7CB47806A3A),
    helpstring("Dispatch interface for CmathLib Object"),
    dual,
    oleautomation
  ]
  interface ICmathLib: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Convert real and imaginary doubles to Variant array of doubles")]
    HRESULT _stdcall cmplx([in] double RealPart, [in] double ImagPart, [out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Return abs value of complex number given in real and imag doubles")]
    HRESULT _stdcall cabs([in] double realpart, [in] double imagpart, [out, retval] double* Value);
    [propget, id(0x000000CB), helpstring("Returns the angle, in degrees, of a complex number specified as two doubles: Realpart and imagpart.")]
    HRESULT _stdcall cdang([in] double RealPart, [in] double ImagPart, [out, retval] double* Value);
    [propget, id(0x000000CC), helpstring("Convert complex number to magnitude and angle, degrees. Returns variant array of two doubles.")]
    HRESULT _stdcall ctopolardeg([in] double RealPart, [in] double ImagPart, [out, retval] VARIANT* Value);
    [propget, id(0x000000CD), helpstring("Convert magnitude, angle in degrees to a complex number. Returns Variant array of two doubles.")]
    HRESULT _stdcall pdegtocomplex([in] double magnitude, [in] double angle, [out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("Multiply two complex numbers: (a1, b1) * (a2, b2). Returns result as a variant array of two doubles.")]
    HRESULT _stdcall cmul([in] double a1, [in] double b1, [in] double a2, [in] double b2, [out, retval] VARIANT* Value);
    [propget, id(0x000000CF), helpstring("Divide two complex number: (a1, b1)/(a2, b2). Returns variant array of two doubles representing complex result.")]
    HRESULT _stdcall cdiv([in] double a1, [in] double b1, [in] double a2, [in] double b2, [out, retval] VARIANT* Value);
  };

  [
    uuid(9714FED4-9D39-4692-B76B-9A18F206A934),
    helpstring("Dispatch interface for Parser Object"),
    dual,
    oleautomation
  ]
  interface IParser: IDispatch
  {
    [propget, id(0x000000C9), helpstring("String to be parsed. Loading this string resets the Parser to the beginning of the line. Then parse off the tokens in sequence.")]
    HRESULT _stdcall CmdString([out, retval] BSTR* Value);
    [propput, id(0x000000C9), helpstring("String to be parsed. Loading this string resets the Parser to the beginning of the line. Then parse off the tokens in sequence.")]
    HRESULT _stdcall CmdString([in] BSTR Value);
    [propget, id(0x000000CA), helpstring("Get next token and return tag name (before = sign) if any. See AutoIncrement.")]
    HRESULT _stdcall NextParam([out, retval] BSTR* Value);
    [propget, id(0x000000CB), helpstring("Default is FALSE. If TRUE parser automatically advances to next token after DblValue, IntValue, or StrValue. Simpler when you don't need to check for parameter names.")]
    HRESULT _stdcall AutoIncrement([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000CB), helpstring("Default is FALSE. If TRUE parser automatically advances to next token after DblValue, IntValue, or StrValue. Simpler when you don't need to check for parameter names.")]
    HRESULT _stdcall AutoIncrement([in] VARIANT_BOOL Value);
    [propget, id(0x000000CC), helpstring("Return next parameter as a double.")]
    HRESULT _stdcall DblValue([out, retval] double* Value);
    [propget, id(0x000000CD), helpstring("Return next parameter as a long integer.")]
    HRESULT _stdcall IntValue([out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Return next parameter as a string")]
    HRESULT _stdcall StrValue([out, retval] BSTR* Value);
    [propget, id(0x000000CF), helpstring("Get the characters used for White space in the command string.  Default is blank and Tab.")]
    HRESULT _stdcall WhiteSpace([out, retval] BSTR* Value);
    [propput, id(0x000000CF), helpstring("Set the characters used for White space in the command string.  Default is blank and Tab.")]
    HRESULT _stdcall WhiteSpace([in] BSTR Value);
    [propget, id(0x000000D0), helpstring("Get String containing the the characters for Quoting in OpenDSS scripts. Matching pairs defined in EndQuote. Default is \"'([{.")]
    HRESULT _stdcall BeginQuote([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Set String containing the the characters for Quoting in OpenDSS scripts. Matching pairs defined in EndQuote. Default is \"'([{.")]
    HRESULT _stdcall BeginQuote([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("String containing characters, in order, that match the beginning quote characters in BeginQuote. Default is \"')]}")]
    HRESULT _stdcall EndQuote([out, retval] BSTR* Value);
    [propput, id(0x000000D1), helpstring("String containing characters, in order, that match the beginning quote characters in BeginQuote. Default is \"')]}")]
    HRESULT _stdcall EndQuote([in] BSTR Value);
    [propget, id(0x000000D2), helpstring("String defining hard delimiters used to separate token on the command string. Default is , and =. The = separates token name from token value. These override whitesspace to separate tokens.")]
    HRESULT _stdcall Delimiters([out, retval] BSTR* Value);
    [propput, id(0x000000D2), helpstring("String defining hard delimiters used to separate token on the command string. Default is , and =. The = separates token name from token value. These override whitesspace to separate tokens.")]
    HRESULT _stdcall Delimiters([in] BSTR Value);
    [id(0x000000D3), helpstring("Reset delimiters to their default values.")]
    HRESULT _stdcall ResetDelimiters(void);
    [propget, id(0x000000D4), helpstring("Returns token as variant array of doubles. For parsing quoted array syntax.")]
    HRESULT _stdcall Vector([in] long ExpectedSize, [out, retval] VARIANT* Value);
    [propget, id(0x000000D5), helpstring("Use this property to parse a Matrix token in OpenDSS format.  Returns square matrix of order specified. Order same as default Fortran order: column by column.")]
    HRESULT _stdcall Matrix([in] long ExpectedOrder, [out, retval] VARIANT* Value);
    [propget, id(0x000000D6), helpstring("Use this property to parse a matrix token specified in lower triangle form. Symmetry is forced.")]
    HRESULT _stdcall SymMatrix([in] long ExpectedOrder, [out, retval] VARIANT* Value);
  };

  [
    uuid(196861FB-38C6-4FB4-B8A5-B2DDA3DDA663),
    helpstring("Dispatch interface for LoadShapes Object"),
    dual,
    oleautomation
  ]
  interface ILoadShapes: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Get the Name of the active Loadshape")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000C9), helpstring("Set the active Loadshape by name")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CA), helpstring("Number of Loadshape objects currently defined in Loadshape collection")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Set the first loadshape active and return integer index of the loadshape. Returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Advance active Loadshape to the next on in the collection. Returns 0 if no more loadshapes.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Variant array of strings containing names of all Loadshape objects currently defined.")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CE), helpstring("Get Number of points in active Loadshape.")]
    HRESULT _stdcall Npts([out, retval] long* Value);
    [propput, id(0x000000CE), helpstring("Set number of points to allocate for active Loadshape.")]
    HRESULT _stdcall Npts([in] long Value);
    [propget, id(0x000000CF), helpstring("Variant array of Doubles for the P multiplier in the Loadshape.")]
    HRESULT _stdcall Pmult([out, retval] VARIANT* Value);
    [propput, id(0x000000CF), helpstring("Variant array of doubles containing the P array for the Loadshape.")]
    HRESULT _stdcall Pmult([in] VARIANT Value);
    [propget, id(0x000000D0), helpstring("Variant array of doubles containing the Q multipliers.")]
    HRESULT _stdcall Qmult([out, retval] VARIANT* Value);
    [propput, id(0x000000D0), helpstring("Variant array of doubles containing the Q multipliers.")]
    HRESULT _stdcall Qmult([in] VARIANT Value);
    [id(0x000000D1), helpstring("Normalize the P and Q curves based on either Pbase, Qbase or simply the peak value of the curve.")]
    HRESULT _stdcall Normalize(void);
    [propget, id(0x000000D2), helpstring("Time array in hours correscponding to P and Q multipliers when the Interval=0.")]
    HRESULT _stdcall TimeArray([out, retval] VARIANT* Value);
    [propput, id(0x000000D2), helpstring("Time array in hours correscponding to P and Q multipliers when the Interval=0.")]
    HRESULT _stdcall TimeArray([in] VARIANT Value);
    [propget, id(0x000000D3), helpstring("Fixed interval time value, hours")]
    HRESULT _stdcall HrInterval([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Fixed interval time value, hours.")]
    HRESULT _stdcall HrInterval([in] double Value);
    [propget, id(0x000000D4), helpstring("Fixed Interval time value, in minutes")]
    HRESULT _stdcall MinInterval([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Fixed Interval time value, in minutes")]
    HRESULT _stdcall MinInterval([in] double Value);
    [id(0x000000D6), helpstring("Make a new Loadshape")]
    long _stdcall New([in] BSTR Name);
    [propget, id(0x000000D7), helpstring("Base for normalizing P curve. If left at zero, the peak value is used.")]
    HRESULT _stdcall Pbase([out, retval] double* Value);
    [propput, id(0x000000D7), helpstring("Base for normalizing P curve. If left at zero, the peak value is used.")]
    HRESULT _stdcall Pbase([in] double Value);
    [propget, id(0x000000D8), helpstring("Base for normalizing Q curve. If left at zero, the peak value is used.")]
    HRESULT _stdcall Qbase([out, retval] double* Value);
    [propput, id(0x000000D8), helpstring("Base for normalizing Q curve. If left at zero, the peak value is used.")]
    HRESULT _stdcall Qbase([in] double Value);
    [propget, id(0x000000D9), helpstring("T/F flag to let Loads know to use the actual value in the curve rather than use the value as a multiplier.")]
    HRESULT _stdcall UseActual([out, retval] VARIANT_BOOL* Value);
    [propput, id(0x000000D9), helpstring("T/F flag to let Loads know to use the actual value in the curve rather than use the value as a multiplier.")]
    HRESULT _stdcall UseActual([in] VARIANT_BOOL Value);
    [propget, id(0x000000D5), helpstring("Fixed interval data time interval, seconds")]
    HRESULT _stdcall Sinterval([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Fixed interval data time interval, seconds")]
    HRESULT _stdcall Sinterval([in] double Value);
  };

  [
    uuid(AABE4DA8-3D5A-447F-AFFB-78946BA68DA5),
    helpstring("Dispatch interface for Fuses Object"),
    dual,
    oleautomation
  ]
  interface IFuses: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing names of all Fuses in the circuit")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Number of Fuse elements in the circuit")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Set the first Fuse to be the active fuse. Returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Advance the active Fuse element pointer to the next fuse. Returns 0 if no more fuses.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Get the name of the active Fuse element")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Set the active Fuse element by name.")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Full name of the circuit element to which the fuse is connected.")]
    HRESULT _stdcall MonitoredObj([out, retval] BSTR* Value);
    [propput, id(0x000000CE), helpstring("Full name of the circuit element to which the fuse is connected.")]
    HRESULT _stdcall MonitoredObj([in] BSTR Value);
    [propget, id(0x000000CF), helpstring("Terminal number to which the fuse is connected.")]
    HRESULT _stdcall MonitoredTerm([out, retval] long* Value);
    [propput, id(0x000000CF), helpstring("Number of the terminal to which the fuse is connected")]
    HRESULT _stdcall MonitoredTerm([in] long Value);
    [propget, id(0x000000D0), helpstring("Full name of the circuit element switch that the fuse controls. Defaults to the MonitoredObj.")]
    HRESULT _stdcall SwitchedObj([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Full name of the circuit element switch that the fuse controls. Defaults to MonitoredObj.")]
    HRESULT _stdcall SwitchedObj([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Number of the terminal containing the switch controlled by the fuse.")]
    HRESULT _stdcall SwitchedTerm([out, retval] long* Value);
    [propput, id(0x000000D1), helpstring("Number of the terminal of the controlled element containing the switch controlled by the fuse.")]
    HRESULT _stdcall SwitchedTerm([in] long Value);
    [propget, id(0x000000D2), helpstring("Name of the TCCcurve object that determines fuse blowing.")]
    HRESULT _stdcall TCCcurve([out, retval] BSTR* Value);
    [propput, id(0x000000D2), helpstring("Name of the TCCcurve object that determines fuse blowing.")]
    HRESULT _stdcall TCCcurve([in] BSTR Value);
    [propget, id(0x000000D3), helpstring("Multiplier or actual amps for the TCCcurve object. Defaults to 1.0.  Multipliy current values of TCC curve by this to get actual amps.")]
    HRESULT _stdcall RatedCurrent([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Multiplier or actual fuse amps for the TCC curve. Defaults to 1.0. Has to correspond to the Current axis of TCCcurve object.")]
    HRESULT _stdcall RatedCurrent([in] double Value);
    [propget, id(0x000000D4), helpstring("A fixed delay time in seconds added to the fuse blowing time determined by the TCC curve. Default is 0.")]
    HRESULT _stdcall Delay([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Fixed delay time in seconds added to the fuse blowing time to represent fuse clear or other delay.")]
    HRESULT _stdcall Delay([in] double Value);
    [id(0x000000D5), helpstring("Manual opening of fuse")]
    HRESULT _stdcall Open(void);
    [id(0x000000D6), helpstring("Close the fuse back in and reset.")]
    HRESULT _stdcall Close(void);
    [id(0x000000D7), helpstring("Current state of the fuses. TRUE if any fuse on any phase is blown. Else FALSE.")]
    VARIANT_BOOL _stdcall IsBlown(void);
    [propget, id(0x000000D8), helpstring("Get/set active fuse by index into the list of fuses. 1 based: 1..count")]
    HRESULT _stdcall idx([out, retval] long* Value);
    [propput, id(0x000000D8), helpstring("Set Fuse active by index into the list of fuses. 1..count")]
    HRESULT _stdcall idx([in] long Value);
    [propget, id(0x000000D9), helpstring("Number of phases, this fuse. ")]
    HRESULT _stdcall NumPhases([out, retval] long* Value);
  };

  [
    uuid(CB2C7310-1717-4C6E-A7B8-DA54CF1722CD),
    helpstring("Dispatch interface for ISources Object"),
    dual,
    oleautomation
  ]
  interface IISources: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Variant array of strings containing names of all ISOURCE elements.")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Count: Number of ISOURCE elements.")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Set the First ISOURCE to be active; returns Zero if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next ISOURCE element to be the active one. Returns Zero if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Get name of active ISOURCE")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Set Active ISOURCE by name")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Get the magnitude of the ISOURCE in amps")]
    HRESULT _stdcall Amps([out, retval] double* Value);
    [propput, id(0x000000CE), helpstring("Set the magnitude of the ISOURCE, amps")]
    HRESULT _stdcall Amps([in] double Value);
    [propget, id(0x000000CF), helpstring("Phase angle for ISOURCE, degrees")]
    HRESULT _stdcall AngleDeg([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Phase angle for ISOURCE, degrees")]
    HRESULT _stdcall AngleDeg([in] double Value);
    [propget, id(0x000000D0), helpstring("The present frequency of the ISOURCE, Hz")]
    HRESULT _stdcall Frequency([out, retval] double* Value);
    [propput, id(0x000000D0), helpstring("Set the present frequency for the ISOURCE")]
    HRESULT _stdcall Frequency([in] double Value);
  };

  [
    uuid(25C5373D-5888-4A0C-974B-77EBD57ED0D1),
    helpstring("Used for communicating directly with DSSim and to extract some specific info"),
    dual,
    oleautomation
  ]
  interface IDSSimComs: IDispatch
  {
    [id(0x000000CA), helpstring("This method delivers the voltage pu of the specified bus, this specification must be with a number (index)")]
    HRESULT _stdcall BusVoltagepu([in] unsigned int Index, [out, retval] VARIANT* Vpu);
    [id(0x000000CB), helpstring("This method delivers the voltage (complex) of the specified bus, this specification must be with a number (index)")]
    HRESULT _stdcall BusVoltage([in] unsigned int Index, [out, retval] VARIANT* Voltages);
  };

  [
    uuid(FAF19717-5887-43F6-8DC3-D0337E1081AD),
    helpstring("Dispatch interface for PVSystems Object"),
    dual,
    oleautomation
  ]
  interface IPVSystems: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Vairant array of strings with all PVSystem names")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Variant Array of PVSYSTEM energy meter register names")]
    HRESULT _stdcall RegisterNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CB), helpstring("Variant array of doubles containing values in PVSystem registers.")]
    HRESULT _stdcall RegisterValues([out, retval] VARIANT* Value);
    [propget, id(0x000000CC), helpstring("Set first PVSystem active; returns 0 if none.")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Sets next PVSystem active; returns 0 if no more.")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CE), helpstring("Number of PVSystems")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CF), helpstring("Get/set active PVSystem by index;  1..Count")]
    HRESULT _stdcall idx([out, retval] long* Value);
    [propput, id(0x000000CF), helpstring("Get/Set Active PVSystem by index:  1.. Count")]
    HRESULT _stdcall idx([in] long Value);
    [propget, id(0x000000D0), helpstring("Get the name of the active PVSystem")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000D0), helpstring("Set the name of the active PVSystem")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000D1), helpstring("Get the present value of the Irradiance property in W/sq-m")]
    HRESULT _stdcall Irradiance([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Set the present Irradiance value in W/sq-m")]
    HRESULT _stdcall Irradiance([in] double Value);
    [propget, id(0x000000D2), helpstring("get kW output")]
    HRESULT _stdcall kW([out, retval] double* Value);
    [propget, id(0x000000D3), helpstring("Get kvar value")]
    HRESULT _stdcall kvar([out, retval] double* Value);
    [propput, id(0x000000D3), helpstring("Set kvar output value")]
    void _stdcall kvar([in] double Value);
    [propget, id(0x000000D4), helpstring("Get Power factor ")]
    HRESULT _stdcall PF([out, retval] double* Value);
    [propput, id(0x000000D4), helpstring("Set PF ")]
    void _stdcall PF([in] double Value);
    [propget, id(0x000000D5), helpstring("Get Rated kVA of the PVSystem")]
    HRESULT _stdcall kVArated([out, retval] double* Value);
    [propput, id(0x000000D5), helpstring("Set kva rated")]
    void _stdcall kVArated([in] double Value);
  };

  [
    uuid(8DCD1962-268B-40E1-B49E-B7C01C3E07CD),
    helpstring("Dispatch interface for Vsources Object"),
    dual,
    oleautomation
  ]
  interface IVsources: IDispatch
  {
    [propget, id(0x000000C9), helpstring("Names of all Vsource objects in the circuit")]
    HRESULT _stdcall AllNames([out, retval] VARIANT* Value);
    [propget, id(0x000000CA), helpstring("Number of Vsource Object")]
    HRESULT _stdcall Count([out, retval] long* Value);
    [propget, id(0x000000CB), helpstring("Sets the first VSOURCE to be active; Returns 0 if none")]
    HRESULT _stdcall First([out, retval] long* Value);
    [propget, id(0x000000CC), helpstring("Sets the next VSOURCE object to be active; returns zero if no more")]
    HRESULT _stdcall Next([out, retval] long* Value);
    [propget, id(0x000000CD), helpstring("Get Active VSOURCE name")]
    HRESULT _stdcall Name([out, retval] BSTR* Value);
    [propput, id(0x000000CD), helpstring("Set Active VSOURCE by Name")]
    HRESULT _stdcall Name([in] BSTR Value);
    [propget, id(0x000000CE), helpstring("Source Voltage in kV")]
    HRESULT _stdcall BasekV([out, retval] double* Value);
    [propput, id(0x000000CE), helpstring("Source voltage in kV")]
    HRESULT _stdcall BasekV([in] double Value);
    [propget, id(0x000000CF), helpstring("Source pu voltage.")]
    HRESULT _stdcall pu([out, retval] double* Value);
    [propput, id(0x000000CF), helpstring("Per-unit value of source voltage based on kV")]
    HRESULT _stdcall pu([in] double Value);
    [propget, id(0x000000D0), helpstring("Phase angle of first phase in degrees")]
    HRESULT _stdcall AngleDeg([out, retval] double* Value);
    [propput, id(0x000000D0), helpstring("phase angle in degrees")]
    HRESULT _stdcall AngleDeg([in] double Value);
    [propget, id(0x000000D1), helpstring("Source Frequency in Hz")]
    HRESULT _stdcall Frequency([out, retval] double* Value);
    [propput, id(0x000000D1), helpstring("Source frequency in Hz")]
    HRESULT _stdcall Frequency([in] double Value);
    [propget, id(0x000000D2), helpstring("Number of Phases")]
    HRESULT _stdcall Phases([out, retval] long* Value);
    [propput, id(0x000000D2), helpstring("Number of phases")]
    HRESULT _stdcall Phases([in] long Value);
  };

  [
    uuid(AE501F77-F7F0-4201-A9AD-6AB385262203),
    helpstring("Events interface for DSSEvents Object")
  ]
  dispinterface IDSSEventsEvents
  {
    properties:
    methods:
    [id(0x000000C9), helpstring("Notification to initialize the control model.")]
    HRESULT InitControls(void);
    [id(0x000000CA), helpstring("Notification that a time step solution is complete, and the control should update itself.")]
    HRESULT StepControls(void);
    [id(0x000000CB), helpstring("Notification that a system solution has been performed, and controls should check and possibly create new events.")]
    HRESULT CheckControls(void);
  };

  [
    uuid(6E20BC4C-67C0-4AD3-9E12-BF90C478A1CC),
    version(1.0),
    helpstring("Text Object\0erface for Text Object\0\0e\0;\0p\x12\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Text
  {
    [default] interface IText;
  };

  [
    uuid(F8410F14-7E85-44A9-B42F-F900DF5F596E),
    version(1.0),
    helpstring("DSSProperty Object\0for DSSProperty Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSSProperty
  {
    [default] interface IDSSProperty;
  };

  [
    uuid(BC5F55A3-7A0F-4923-B218-098A91F482D8),
    version(1.0),
    helpstring("CktElementObject\0e for CktElement Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass CktElement
  {
    [default] interface ICktElement;
  };

  [
    uuid(0038D0EB-28ED-42B0-A247-E212E05ADF4B),
    version(1.0),
    helpstring("Error Object\0rface for Errror Object\0ect\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Error
  {
    [default] interface IError;
  };

  [
    uuid(B5B695B1-A1F5-444F-ABC5-836B7EF1DF0D),
    version(1.0),
    helpstring("Circuit Object\0ace for Circuit Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Circuit
  {
    [default] interface ICircuit;
  };

  [
    uuid(A14C32E4-846B-444D-9070-F7A31E9F5FF9),
    version(1.0),
    helpstring("Bus Object\0terface for Bus Object\0ect\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Bus
  {
    [default] interface IBus;
  };

  [
    uuid(6FE9D1B8-C064-4877-94C0-F13882ADBDB6),
    version(1.0),
    helpstring("DSS Main Object\0ce for DSSMain Object\0ct\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSS
  {
    [default] interface IDSS;
  };

  [
    uuid(F799E1DE-E7BF-4F86-BCED-6DD01FD00419),
    version(1.0),
    helpstring("Solution Object\0ce for Solution Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Solution
  {
    [default] interface ISolution;
  };

  [
    uuid(7FF93D6F-4258-40CB-9558-0792422309F3),
    version(1.0),
    helpstring("Monitors Object\0ce for Monitors Object\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Monitors
  {
    [default] interface IMonitors;
  };

  [
    uuid(F869D5BB-A023-48AB-A459-01444585B7C1),
    version(1.0),
    helpstring("Meters Object\0face for Meters Object\0t\0t\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Meters
  {
    [default] interface IMeters;
  };

  [
    uuid(65F232C9-7D95-4E45-B9FA-40F518CFBB64),
    version(1.0),
    helpstring("Generators Object\0 for Generators Object\0\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Generators
  {
    [default] interface IGenerators;
  };

  [
    uuid(4CB900D9-DD2F-41AF-9E48-B999E0AED0A7),
    version(1.0),
    helpstring("DSSProgress Object\0for DSSProgress Object\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSSProgress
  {
    [default] interface IDSSProgress;
  };

  [
    uuid(9D910AA4-0CB3-4907-AEEF-8DD79A58C0AD),
    version(1.0),
    helpstring("Settings Object\0ce for Settings Object\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Settings
  {
    [default] interface ISettings;
  };

  [
    uuid(A1352870-9D53-4E48-B83A-6DB0C8FED65B),
    version(1.0),
    helpstring("Lines Object\0rface for Lines Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Lines
  {
    [default] interface ILines;
  };

  [
    uuid(19DD7174-7FEE-4E59-97ED-C54F16EDC3F0),
    version(1.0),
    helpstring("CtrlQueue\0for CtrlQueue Object\0ject\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass CtrlQueue
  {
    [default] interface ICtrlQueue;
  };

  [
    uuid(1302A34B-A554-4C32-BCED-4AF0A94FF114),
    version(1.0),
    helpstring("Loads Object\0rface for Loads Object\0ct\0ct\0\b\x03|\x12\b\x03\x12\b\x03\x12\b\x03\x01\x1B\x04`N\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Loads
  {
    [default] interface ILoads;
  };

  [
    uuid(09D4B4AB-DF58-4F8F-A3F0-72F32830B337),
    version(1.0),
    helpstring("DSSElement Object\0 for DSSElement Object\0\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSSElement
  {
    [default] interface IDSSElement;
  };

  [
    uuid(2A02BB33-50A4-4C87-86E0-59EF7738F86C),
    version(1.0),
    helpstring("ActiveClass Object\0for ActiveClass Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass ActiveClass
  {
    [default] interface IActiveClass;
  };

  [
    uuid(F733F571-4CEC-45CC-922D-16C2BEEBA5BC),
    version(1.0),
    helpstring("\0\x01spatch interface for Capacitors\0 Object\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Capacitors
  {
    [default] interface ICapacitors;
  };

  [
    uuid(3A3E2154-1249-4DBB-AEDC-C4C14300D332),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Transformers
  {
    [default] interface ITransformers;
  };

  [
    uuid(7D8F53AE-0D61-4B87-9BEE-12D54052F689),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass SwtControls
  {
    [default] interface ISwtControls;
  };

  [
    uuid(7D95304E-B0A8-4531-8D1B-F438287EEA6E),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass CapControls
  {
    [default] interface ICapControls;
  };

  [
    uuid(D3DBDE53-6397-4C36-8C87-9BEA061FBC78),
    version(1.0),
    helpstring("\0\x01spatch interface for RegControls\0\0bject\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass RegControls
  {
    [default] interface IRegControls;
  };

  [
    uuid(5B1B5AB3-0595-4E46-B64B-CF8877ED0857),
    version(1.0),
    helpstring("Topology Object\0ce for Topology Object\0\0n\0t\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass Topology
  {
    [default] interface ITopology;
  };

  [
    uuid(D00898D0-6CC7-4A3B-BF89-DED9593579E7),
    version(1.0),
    helpstring("DSS_Executive Object\0r DSS_Executive Object\0a\0t\0i\0o\0n\0r\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\a\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
  ]
  coclass DSS_Executive
  {
    [default] interface IDSS_Executive;
  };

  [
    uuid(B734843A-08E4-42D3-9E24-C0D5F7BF6487),
    helpstring("DSSEvents Object")
  ]
  coclass DSSEvents
  {
    [default] interface IDSSEvents;
    [default, source] dispinterface IDSSEventsEvents;
  };

  [
    uuid(FC54E9AA-1C6A-4CF8-837D-82B257D98E5A),
    helpstring("Sensors Object")
  ]
  coclass Sensors
  {
    [default] interface ISensors;
  };

  [
    uuid(9594F37D-E47E-4701-892B-52BE7E576E87),
    helpstring("XYCurves Object")
  ]
  coclass XYCurves
  {
    [default] interface IXYCurves;
  };

  [
    uuid(4DDCDADD-A1D3-40BB-98E7-B023BD3947BE),
    helpstring("PDElements Object")
  ]
  coclass PDElements
  {
    [default] interface IPDElements;
  };

  [
    uuid(B92B059F-FEFD-4554-8F07-AFDCEFBBEA7B),
    helpstring("Reclosers Object")
  ]
  coclass Reclosers
  {
    [default] interface IReclosers;
  };

  [
    uuid(9D887EEA-7454-4214-BC56-AC42F5A3318E),
    helpstring("Relays Object")
  ]
  coclass Relays
  {
    [default] interface IRelays;
  };

  [
    uuid(76847D49-B650-4850-9486-E08B48F87E39),
    helpstring("CmathLib Object")
  ]
  coclass CmathLib
  {
    [default] interface ICmathLib;
  };

  [
    uuid(2245AD88-CB0E-4426-9DF2-5B2F89B2A08D),
    helpstring("Parser Object")
  ]
  coclass Parser
  {
    [default] interface IParser;
  };

  [
    uuid(4FCBE090-AA15-4E31-A8C7-E5F42D41C90C),
    helpstring("LoadShapes Object")
  ]
  coclass LoadShapes
  {
    [default] interface ILoadShapes;
  };

  [
    uuid(ABED90F5-3908-408A-87EF-D0582FD2FFD5),
    helpstring("Fuses Object")
  ]
  coclass Fuses
  {
    [default] interface IFuses;
  };

  [
    uuid(CE35EBD2-BDD4-4B01-AE88-1D90DC82F619),
    helpstring("ISource Object")
  ]
  coclass ISources
  {
    [default] interface IISources;
  };

  [
    uuid(2104B607-8D58-4BBD-85B8-4E5F1C8BD6BE),
    helpstring("DSSimComs Object")
  ]
  coclass DSSimComs
  {
    [default] interface IDSSimComs;
  };

  [
    uuid(D8D7592D-D5CD-4E27-870D-00D654DF2D3C),
    helpstring("PVSystems Object")
  ]
  coclass PVSystems
  {
    [default] interface IPVSystems;
  };

  [
    uuid(0823B8BD-AD34-452B-974A-F46BA25D49EA),
    helpstring("Vsources Object")
  ]
  coclass Vsources
  {
    [default] interface IVsources;
  };

};
